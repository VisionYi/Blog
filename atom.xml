<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Visionyi 鹹魚&#39;s blog</title>
  
  <subtitle>~我的學習天地，走出舒適沙發，踏進夢想步伐~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://visionyi.github.io/"/>
  <updated>2019-02-10T12:39:41.603Z</updated>
  <id>https://visionyi.github.io/</id>
  
  <author>
    <name>Visionyi 鹹魚</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>北漂追尋理想工作與重新生活的這些日子</title>
    <link href="https://visionyi.github.io/2019/02/08/go-to-taipei-find-a-job-and-lift/"/>
    <id>https://visionyi.github.io/2019/02/08/go-to-taipei-find-a-job-and-lift/</id>
    <published>2019-02-07T16:00:00.000Z</published>
    <updated>2019-02-10T12:39:41.603Z</updated>
    
    <content type="html"><![CDATA[<p>相信已有一些人知道，我自從 2018 年 9 月初開始到現在，已經在台北生活與工作好幾個月了。自己雖然有家業公司可以繼承，但為何還要大老遠北上找工作呢？</p><p>是的！就是想去看看這更廣的世界與社會，體驗出外獨自生活的感受。另外，自己的家業是傳產加工業，跟自己的興趣與理想差很多，這部分跟父母討論了很多，自己想要的工作經驗也都在北部，想讓自己能夠獨當一面出外學習與成長，此刻我就下定決心前往北部工作了。<br><a id="more"></a></p><h2 id="北部找工作應徵的時期"><a href="#北部找工作應徵的時期" class="headerlink" title="北部找工作應徵的時期"></a>北部找工作應徵的時期</h2><p>自己的理想職位是「Front-End Developer 網頁前端工程師」，其實我在應徵工作前很早就在準備我的工作履歷與作品集了，8 月前的 4 個多月的時間裡，都在不斷地精進這項工作的技能與相關知識，自我學習，甚至線下社群交流也會去看看。</p><p>最後運用網路上的資源與課程，做出了一些網頁作品，加上之前實習時所遺留的專案再重整，放進我精心製作的 CakeResume 履歷中，整理擦亮自己的 Blog &amp; Github 也跟著放進去。</p><p>接著到了 8 月多時，陸陸續續投遞了好幾家公司，由於自我的工作經驗不足，只有大學一年的實習經驗，所以幾乎都是找新創公司居多，並以前端 Vue 框架為主。</p><p>先來講講應徵面試前的準備真的不簡單:</p><ul><li>技術：職業相關的面試考題與技術問答</li><li>經驗：工作上相關的經驗處理，與夥伴的溝通或合作的問題</li><li>必答題：<ul><li>自我介紹</li><li>為何想加入我們公司？</li><li>與上份工作的差異或相關問題</li><li>未來想在公司學到或獲得什麼？</li><li>…等等</li></ul></li><li>換面試者提問：(這裡簡單講幾個)<ul><li>ㄧ天的工作流程，專案分布程序、人數、時間規劃？</li><li>如何與其他職位合作？使用的工具與技術？</li><li>目前專案的內容？下個階段或未來的發展方向？</li><li>公司制度相關、福利相關</li></ul></li><li>Cover Letter 求職信的撰寫</li></ul><p>總共投了 12 家公司，最後只有收到 8 家公司的面試邀請，外加 1 家主動邀請的，全都在台北與新北市，所以當下就安排全部集中在下週 4 天的時間，剛好那個禮拜週末有個社群 COSCUP 開源年會想參加，也就是直接北上 6 天 5 夜的行程，找了兩家青年旅社住宿，初次在台北短暫的生活體驗。</p><p>在陸陸續續經過每一天的面試行程後，真的都有不同的感受，每家公司至少都會有 <strong>技術層面的考試或測驗</strong>，再來 <strong>與 HR ＆ 技術主管或資深同事的面試</strong>，有些更深入的還有 <strong>智能與個性的測驗</strong>，最後如果還有 <strong>CEO 或 co-founder 的面談</strong> 那就更為重要了。</p><p>公司想要的人才都不盡相同，技術能力強的、個性與公司文化相符的、工作經驗豐富的…等等，這讓我知道自己其實還缺少很多東西，自己的心態也不斷再轉變，不管結果是好是壞，重視每一次的面試過程，盡心說出與寫出最好的內容，儘管是沒遇過的或不會的也要說出「這項內容目前還不夠瞭解，進入公司如有需求會在加強學習充分瞭解它的」，表現出主動學習的態度，讓面試官瞭解自己對這份工作的慾望心。</p><p>在被公司面試挑選時，相對的，自己也是在挑選想要的公司，運用最後面試者的提問去多瞭解公司的文化、人事物、技術工具、環境、制度…等等，讓自己對未來的工作內容有更多憧憬，明確這就是我想要的。</p><p>當時內心的理想公司也慢慢確立在心中： (期望順序)</p><ol><li>符合我想加強的主要前端技術 - Vue，還有後端技術能自我學習</li><li>能夠學習團隊合作、分工管理的經驗</li><li>公司理想，希望有自主品牌，能擁有更多未來的展望</li><li>公司文化，類似扁平化的管理，希望能自主規劃時間</li><li>薪資期待</li><li>福利、考核、升遷制度</li></ol><p>全面試完成後過了兩週的結果，9 間公司裏有 2 間我主動在面試時推掉，2 間無聲卡，3 間好人卡，2 間有取得 offer，其中我有一間最想去的 <strong>TenTen 転転</strong> 在面試第二關就被打掉了，真的很懊悔自己能力真的很有限啊！</p><p>最後剩下的兩間公司，一間主打未來潛力高推向國際的 ‘雲端醫療’，另一間主打福利與薪資都比前者高的 ‘博弈產業’，我最終選擇了前者，我相信擁有很高的未來展望與學習動機的公司是我最好的選擇，能讓自己隨著公司一同成長。</p><p>後記：</p><p>現在回憶起來，雖然我都是應徵 junior 工程師級的，但這結果真的很不如預期啊！自己當時體驗最深的應該就是：<strong>工作經驗與溝通經驗非常不足</strong>，面對問題的解決態度也需要再更具體才行，另外我開的薪資期待過於高也是個缺陷，導致於取得 offer 的難度真的提高不少，不管怎麼說這都是非常棒的體驗，會好好謹記在心的，人生第一次的應徵面試之旅就此獻給了台北。</p><hr><h2 id="台北上班生活"><a href="#台北上班生活" class="headerlink" title="台北上班生活"></a>台北上班生活</h2><p>剛好到今年 2019 過新年前已經滿 5 個月了，讓我有滿滿的體悟與一些初體驗。我以最年輕的員工進入了這間 Health2Sync 雲端醫療公司，初始配備 Mac pro ＋ 24 吋螢幕，座位旁就坐著 CEO，還有 BD 行銷團隊，辦公室為開放式格局，顯得非常寬敞，這真的非常特別啊！</p><p>我的前端前輩有將近 3 年多的經驗，很感謝她很耐心的指導，讓我更熟悉公司的許多專案，還有關於糖尿病這檔事也瞭解不少，另外，還有跟其同事相處真的很融洽，不會有年紀上的隔閡，能夠把彼此當成真的朋友對待，想聊什麼都行。除了這些很棒的工作氣氛，還有非常彈性的上下班與休息時間，任何時段想出去都可以，只要工作能做完就沒問題啦！</p><p>這幾個月的時間也參加了不少活動，3天2夜員工旅遊、同事的婚禮、與日本員工的聚餐、聖誕節節慶美食饗宴、公司的溫馨又瘋狂的尾牙，這都真的都很棒呢！</p><p>對了，關於工作上的歷經我也學習蠻多的，讓我最印像深刻的就是</p><ul><li><strong>團隊間的配合與溝通上的重要性</strong></li></ul><p>以前在製作網頁專案時，都是我自己一人擔當全部要角，直接取用網路上很初始的設計稿 + Github page 靜態 server + 開源公開的 API 或是搭配 json server 自製簡易的 API，沒什麼規則性，想隨時改動都行</p><p>但有了真實團隊的 desgin framework、backend API &amp; server、PM user story &amp; 需求，這就完全不同層級的，按規畫好的結構與排程走，雖然只需要專注在自己的專業上，但細節部分就得更深入，測試就要全面瀏覽器支援了。另外團隊溝通就是更重要的一環，最常碰到的：</p><ul><li>時間不足或太困難需要簡化內容</li><li>某個設計的架構需要與資料搭配做改變</li><li>無法證實你的需求內容，需要更具體一些</li></ul><p>以上這些是讓我體驗最深的，這絕對不是一人接案就能瞭解的。</p><p>當然還有其他的成長，遇到問題與處理事情的態度、評估實作的時間與優先完成的順序，這也都是新的體悟，可以看到真的工作好幾年的人，不只是技術上非常熟練，以上這些經驗也都是非常老道吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信已有一些人知道，我自從 2018 年 9 月初開始到現在，已經在台北生活與工作好幾個月了。自己雖然有家業公司可以繼承，但為何還要大老遠北上找工作呢？&lt;/p&gt;
&lt;p&gt;是的！就是想去看看這更廣的世界與社會，體驗出外獨自生活的感受。另外，自己的家業是傳產加工業，跟自己的興趣與理想差很多，這部分跟父母討論了很多，自己想要的工作經驗也都在北部，想讓自己能夠獨當一面出外學習與成長，此刻我就下定決心前往北部工作了。&lt;br&gt;
    
    </summary>
    
      <category term="心情札記" scheme="https://visionyi.github.io/categories/%E5%BF%83%E6%83%85%E6%9C%AD%E8%A8%98/"/>
    
    
      <category term="生活點滴" scheme="https://visionyi.github.io/tags/%E7%94%9F%E6%B4%BB%E9%BB%9E%E6%BB%B4/"/>
    
      <category term="紀錄回顧" scheme="https://visionyi.github.io/tags/%E7%B4%80%E9%8C%84%E5%9B%9E%E9%A1%A7/"/>
    
  </entry>
  
  <entry>
    <title>The F2E 挑戰之學習筆記 - Filter 高雄旅遊景點</title>
    <link href="https://visionyi.github.io/2018/07/24/The-F2E-Filter/"/>
    <id>https://visionyi.github.io/2018/07/24/The-F2E-Filter/</id>
    <published>2018-07-23T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.026Z</updated>
    
    <content type="html"><![CDATA[<p>這是參與了 <strong>The F2E - 前端修練精神時光屋</strong> 社群活動中的一個挑戰項目: <strong>Filter</strong>。這裡紀錄此專案撰寫時的一些心得與筆記。</p><h2 id="專案使用的技術"><a href="#專案使用的技術" class="headerlink" title="專案使用的技術"></a>專案使用的技術</h2><ul><li>Vue、Vuex、vue-router</li><li>SCSS</li><li>Axios</li><li>串接第三方 API (高雄市政府 Open Data)</li><li>Vuetify 基於 vue2.x 的 UI 組件框架</li></ul><a id="more"></a><h2 id="專案連結"><a href="#專案連結" class="headerlink" title="專案連結"></a>專案連結</h2><ul><li><a href="https://visionyi.github.io/F2E-filter">Live dome</a></li><li><a href="https://github.com/VisionYi/F2E-filter" target="_blank" rel="noopener">Source code</a></li></ul><h2 id="技術開發時遇到的坑-amp-筆記內容"><a href="#技術開發時遇到的坑-amp-筆記內容" class="headerlink" title="技術開發時遇到的坑 &amp; 筆記內容"></a>技術開發時遇到的坑 &amp; 筆記內容</h2><h3 id="網頁切版、設計"><a href="#網頁切版、設計" class="headerlink" title="網頁切版、設計"></a>網頁切版、設計</h3><ul><li><p>img 圖片的 RWD 響應式設計</p><ul><li>隨著頁面寬度改變而改變高度</li><li>可維持比例 16 : 9</li><li>可外框固定大小後讓圖片置中</li></ul></li><li><p>使用 CSS 截斷文字內容，自動限制行數</p><ul><li>可搭配 RWD 響應式設計，當寬度減少時，也會自動截斷更多內容</li><li>參考: <a href="https://css-tricks.com/line-clampin/" target="_blank" rel="noopener">Line Clampin’ (Truncating Multiple Line Text)</a></li><li>以下為基本配置:</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.line-clamp</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">-webkit-line-clamp</span>: <span class="number">2</span>; <span class="comment">/* 限制行數 */</span></span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: vertical;  <span class="comment">/* 內容為橫向字，垂直排列下去 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JS-功能-amp-Vue-的使用"><a href="#JS-功能-amp-Vue-的使用" class="headerlink" title="JS 功能 &amp; Vue 的使用"></a>JS 功能 &amp; Vue 的使用</h3><ul><li><p>vue 生命週期 mounted 的使用時機</p><ul><li><p>瀏覽器進行以下階段時，將調用此函數鉤子</p><ul><li>當頁面所有 DOM 元素都第一次渲染完成</li><li>vue 的所有實例資料掛載完成後</li></ul></li><li><p>在此進行以下操作</p><ul><li>執行 ajax 資料請求</li><li>執行資料初始化，包含 Vuex store 的 資料狀態</li><li>取得 <code>vm.$refs</code>、<code>window</code>、<code>document</code> 之 DOM 元素，執行資料初始化</li><li>執行全局的 <code>window</code> 監聽事件 scroll, resize 之類的</li></ul></li><li>參考 : <a href="https://segmentfault.com/a/1190000008570622" target="_blank" rel="noopener">關於 Vue 實例的生命週期 created &amp; mounted 的區別</a></li></ul></li><li><p>vue 的動畫 &amp; 元素轉場操作</p><ul><li>使用 <code>&lt;transition&gt;</code> 標籤</li></ul></li><li><p>執行全局的 <code>window</code> 監聽事件時</p><ul><li>需特別注意元素是否隨著頁面而改變，包含 vue 綁定的資料與狀態</li><li>需要事先初始化有被操作的資料</li><li>可在外層封裝一個 debounce 函數，避免資料操作過度頻繁</li></ul></li><li><p>vue.directives 的進階使用</p><ul><li>使用函數鉤子 <code>inserted</code></li><li>當 DOM 元素被綁定與渲染完成後調用 (被 vue 插入節點中時調用)</li><li>可用於全局 window 監聽事件來綁定 DOM 元素的操作，參數值可以是函數</li></ul></li><li><p>vuex store 資料與 <code>v-model</code> 做結合</p><ul><li>需要另做一個 computed 類型的資料</li><li>使用 computed 的 <code>get()</code> 取得 store getters 資料</li><li>使用 computed 的 <code>set()</code> 執行 store mutations 操作資料</li><li>如果是表單的 input text 雙向綁定資料，建議在外層封裝一個 debounce 函數</li></ul></li><li><p><code>element.offsetTop</code> 取得的<strong>高度</strong>不一定是元素的頂部到達整個頁面的頂部距離，會依照元素的所在位置而改變</p></li></ul><h3 id="資料頁面構想"><a href="#資料頁面構想" class="headerlink" title="資料頁面構想"></a>資料頁面構想</h3><ul><li>頁面的資料是否會變動，可能會新增或減少呢！？</li><li>必須事先決定清楚，非常關鍵！會影響後續的資料結構與整合。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這是參與了 &lt;strong&gt;The F2E - 前端修練精神時光屋&lt;/strong&gt; 社群活動中的一個挑戰項目: &lt;strong&gt;Filter&lt;/strong&gt;。這裡紀錄此專案撰寫時的一些心得與筆記。&lt;/p&gt;
&lt;h2 id=&quot;專案使用的技術&quot;&gt;&lt;a href=&quot;#專案使用的技術&quot; class=&quot;headerlink&quot; title=&quot;專案使用的技術&quot;&gt;&lt;/a&gt;專案使用的技術&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Vue、Vuex、vue-router&lt;/li&gt;
&lt;li&gt;SCSS&lt;/li&gt;
&lt;li&gt;Axios&lt;/li&gt;
&lt;li&gt;串接第三方 API (高雄市政府 Open Data)&lt;/li&gt;
&lt;li&gt;Vuetify 基於 vue2.x 的 UI 組件框架&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="網頁開發" scheme="https://visionyi.github.io/categories/%E7%B6%B2%E9%A0%81%E9%96%8B%E7%99%BC/"/>
    
    
      <category term="web" scheme="https://visionyi.github.io/tags/web/"/>
    
      <category term="note" scheme="https://visionyi.github.io/tags/note/"/>
    
      <category term="CSS/SCSS" scheme="https://visionyi.github.io/tags/CSS-SCSS/"/>
    
      <category term="Vue" scheme="https://visionyi.github.io/tags/Vue/"/>
    
      <category term="樣版設計" scheme="https://visionyi.github.io/tags/%E6%A8%A3%E7%89%88%E8%A8%AD%E8%A8%88/"/>
    
  </entry>
  
  <entry>
    <title>The F2E 挑戰之學習筆記 - Product Gallery</title>
    <link href="https://visionyi.github.io/2018/07/04/The-F2E-Product-Gallery/"/>
    <id>https://visionyi.github.io/2018/07/04/The-F2E-Product-Gallery/</id>
    <published>2018-07-03T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.026Z</updated>
    
    <content type="html"><![CDATA[<p>這是參與了 ‎<strong>The F2E - 前端修練精神時光屋</strong> 社群活動中的一個挑戰項目: <strong>Product Gallery</strong>。這裡紀錄此專案撰寫時的一些心得與筆記。</p><h2 id="專案使用的技術"><a href="#專案使用的技術" class="headerlink" title="專案使用的技術"></a>專案使用的技術</h2><ul><li>CSS Grid</li><li>SCSS</li><li>Pracel 零配置極速打包工具</li></ul><a id="more"></a><h2 id="專案連結"><a href="#專案連結" class="headerlink" title="專案連結"></a>專案連結</h2><ul><li><a href="https://visionyi.github.io/F2E-product-gallery/">Live dome</a></li><li><a href="https://github.com/VisionYi/F2E-product-gallery" target="_blank" rel="noopener">Source code</a></li></ul><h2 id="專案開發時遇到的坑-amp-筆記內容"><a href="#專案開發時遇到的坑-amp-筆記內容" class="headerlink" title="專案開發時遇到的坑 &amp; 筆記內容"></a>專案開發時遇到的坑 &amp; 筆記內容</h2><h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><ul><li><p>當多個 HTML 頁面時，需要在各自的 HTML 裡直接引入 css/scss/less, js/jsx 檔案</p></li><li><p>由於 dist 和 .cache 在建置後或開啟 server 時，不會把原先的檔案刪除，需要事先手動刪除</p><ul><li>在執行命令前可以先下 <code>rm -rf dist &amp;&amp; rm -rf .cache</code> 清除原先的檔案</li></ul></li><li><p>當不同的檔案在同個時間下，加載到同一個需要被編譯的檔案時，就會出現 bug</p><ul><li>例如: 本專案在觀看 product.html 時，更改 scss 檔案儲存就會有 Error，等待官方修復</li></ul></li></ul><h3 id="CSS-Grid"><a href="#CSS-Grid" class="headerlink" title="CSS Grid"></a>CSS Grid</h3><ul><li><p>教學指南參考: <a href="https://css-tricks.com/snippets/css/complete-guide-grid/#prop-grid-area" target="_blank" rel="noopener">A Complete Guide to Grid</a></p></li><li><p>Gird 父元素主要使用以下 CSS 屬性 (常用)</p><ul><li><code>grid-template</code> (<code>-columns</code> &amp; <code>-rows</code>) - 指定網格的長寬數值與數量</li><li><code>grid-gap</code> - 設定間距大小</li><li><code>grid-auto-rows</code> - 指定剩餘的 row 長度，在內容不明確時可用</li><li><code>align-items</code> - 上下對齊</li><li><code>justify-content</code> - 全體左右對齊或分散</li></ul></li><li><p>Gird 子元素主要使用以下 CSS 屬性 (常用)</p><ul><li><code>grid-column</code> &amp; <code>grid-row</code> - 指定範圍或明確座標<ul><li>內容值為 <code>開始位置 / 結束位置</code></li></ul></li><li><code>grid-area</code> - 上面屬性的合體<ul><li>內容值為 <code>col 開始 / row 開始 / col 結束 / row 結束</code></li></ul></li><li><code>align-self</code> &amp; <code>justify-self</code> - 上下對齊 &amp; 左右對齊</li></ul></li><li><p>當子元素要指定放置的範圍時，可以使用以下撰寫方式:</p><ul><li><code>grid-column: x / span n格數;</code> + <code>grid-row: y / span n格數;</code></li><li><code>grid-area: x / y / span n格數 / span n格數;</code></li><li>單獨使元素靠上下或左右對齊的 CSS 屬性為:<ul><li><code>align-self</code> &amp; <code>justify-self</code></li></ul></li></ul></li><li><p>當父元素 <code>grid-template-columns</code> 在指定欄位寬度的實際數值後，不代表全部加總後就是實際的 <code>width</code> 長度，<code>width</code> 還是 auto</p><ul><li>由於 <code>width</code> 沒有真的數值，所以使用 margin 左右等於 auto 時是不會置中的</li><li>不依賴 <code>width</code> 時，可使用 <code>justify-content: center;</code> 就能置中</li></ul></li></ul><h3 id="其他-CSS-SCSS-技巧"><a href="#其他-CSS-SCSS-技巧" class="headerlink" title="其他 CSS/SCSS 技巧"></a>其他 CSS/SCSS 技巧</h3><ul><li>使圖片只顯示局部區域，常用於只取中間固定長寬的位置，超過長寬的都隱藏起來<ul><li>為 img 標籤加上一個外層元素<ul><li>CSS 屬性加上 <code>overflow: hidden;</code>，超過就隱藏</li><li>原本是指定 img 標籤的長寬大小，現在則改為指定此層元素的大小，而 img 設置為 <code>width: 100%</code> 就可以了</li></ul></li><li>外層元素再使用 flex 垂直置中的方式</li><li>或是 img 使用 <a href="https://stackoverflow.com/questions/40530101/why-is-translatey-50-needed-to-center-an-element-which-is-at-top-50" target="_blank" rel="noopener">translateY(-50%)</a> 垂直置中的方式</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這是參與了 ‎&lt;strong&gt;The F2E - 前端修練精神時光屋&lt;/strong&gt; 社群活動中的一個挑戰項目: &lt;strong&gt;Product Gallery&lt;/strong&gt;。這裡紀錄此專案撰寫時的一些心得與筆記。&lt;/p&gt;
&lt;h2 id=&quot;專案使用的技術&quot;&gt;&lt;a href=&quot;#專案使用的技術&quot; class=&quot;headerlink&quot; title=&quot;專案使用的技術&quot;&gt;&lt;/a&gt;專案使用的技術&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CSS Grid&lt;/li&gt;
&lt;li&gt;SCSS&lt;/li&gt;
&lt;li&gt;Pracel 零配置極速打包工具&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="網頁開發" scheme="https://visionyi.github.io/categories/%E7%B6%B2%E9%A0%81%E9%96%8B%E7%99%BC/"/>
    
    
      <category term="web" scheme="https://visionyi.github.io/tags/web/"/>
    
      <category term="note" scheme="https://visionyi.github.io/tags/note/"/>
    
      <category term="CSS/SCSS" scheme="https://visionyi.github.io/tags/CSS-SCSS/"/>
    
      <category term="樣版設計" scheme="https://visionyi.github.io/tags/%E6%A8%A3%E7%89%88%E8%A8%AD%E8%A8%88/"/>
    
  </entry>
  
  <entry>
    <title>The F2E 挑戰之學習筆記 - TodoList</title>
    <link href="https://visionyi.github.io/2018/06/28/The-F2E-TodoList/"/>
    <id>https://visionyi.github.io/2018/06/28/The-F2E-TodoList/</id>
    <published>2018-06-27T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.027Z</updated>
    
    <content type="html"><![CDATA[<p>這是參與了 <strong>The F2E - 前端修練精神時光屋</strong> 社群活動中的一個挑戰項目: <strong>TodoList</strong>。這裡紀錄此專案撰寫時的一些心得與筆記。</p><h2 id="專案使用的技術"><a href="#專案使用的技術" class="headerlink" title="專案使用的技術"></a>專案使用的技術</h2><ul><li>Vue、Vuex</li><li>SCSS</li><li>LocalStorage</li><li>完全手刻切版</li></ul><a id="more"></a><h2 id="專案連結"><a href="#專案連結" class="headerlink" title="專案連結"></a>專案連結</h2><ul><li><a href="https://visionyi.github.io/F2E-todoList/">Live dome</a></li><li><a href="https://github.com/VisionYi/F2E-todoList" target="_blank" rel="noopener">Source code</a></li></ul><h2 id="技術開發時遇到的坑-amp-筆記內容"><a href="#技術開發時遇到的坑-amp-筆記內容" class="headerlink" title="技術開發時遇到的坑 &amp; 筆記內容"></a>技術開發時遇到的坑 &amp; 筆記內容</h2><h3 id="網頁切版、設計"><a href="#網頁切版、設計" class="headerlink" title="網頁切版、設計"></a>網頁切版、設計</h3><ul><li><p>自訂的 checkbox</p></li><li><p>自訂的 file 上傳按鈕</p></li><li><p>button 如果是 icon 時，當觸發 hover 功能可以產生淡化的背景提示，這是一個按鈕</p><ul><li>可以在元素的 <code>::before</code> 上使用 <code>position: absolute</code>，就能避免原始元素會改變位置或大小</li><li><code>background-color: currentColor</code> 可以抓取當前的 <code>color</code> 屬性內容值</li><li>之後再搭配 <code>opacity</code> 就能自動產生不同的淡化背景</li></ul></li><li><p>helps classes 可以事先產生多種</p><ul><li>margin 間距</li><li>背景或文字顏色</li></ul></li><li><p><strong>狀態類型的或可搭配 JS 來顯示的 CSS 樣式</strong>，這種類型的需要特別獨立出來，可以加上 prefix 字樣 <code>js-*</code>，最後都會改由 JS 來控制，好處是可一統管理顯示與隱藏的狀態變化</p></li></ul><h3 id="JS-功能-amp-Vue-的使用"><a href="#JS-功能-amp-Vue-的使用" class="headerlink" title="JS 功能 &amp; Vue 的使用"></a>JS 功能 &amp; Vue 的使用</h3><ul><li><p>狀態管理很重要，可以藉由狀態資訊改變各種 CSS 樣式 &amp; DOM 顯示隱藏</p></li><li><p>vuex store 中的 actions 都需要事先加上<strong>初始化的方法</strong>，以防需要使用 API 後端資料時，資料結構會與前端差很多</p></li><li><p>vue directives 的使用方式</p></li><li><p>使用以下方法應用在 vue data 資料時，需要避免 vue 無限循環觀察 (observer) data 的變化，尤其使用在 v-for 更需要如此</p><ul><li>陣列函數中自身會變異的方法<ul><li><code>Array.prototype.reverse</code></li><li><code>Array.prototype.sort</code></li></ul></li><li>必須先把 data 淺拷貝成原始的 Array 型態，脫離 vue 的綁定觀察</li><li>使用賦值解構拷貝成新的資料 <code>[...this.items]</code>，再放入 computed 裡讓 vue 繼續觀察變動</li><li>參考: <a href="https://stackoverflow.com/questions/49467217/vuejs-v-for-infinite-update-loop-using-array-prototype-reverse" target="_blank" rel="noopener">Vuejs v-for infinite update loop using reverse() or sort()</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這是參與了 &lt;strong&gt;The F2E - 前端修練精神時光屋&lt;/strong&gt; 社群活動中的一個挑戰項目: &lt;strong&gt;TodoList&lt;/strong&gt;。這裡紀錄此專案撰寫時的一些心得與筆記。&lt;/p&gt;
&lt;h2 id=&quot;專案使用的技術&quot;&gt;&lt;a href=&quot;#專案使用的技術&quot; class=&quot;headerlink&quot; title=&quot;專案使用的技術&quot;&gt;&lt;/a&gt;專案使用的技術&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Vue、Vuex&lt;/li&gt;
&lt;li&gt;SCSS&lt;/li&gt;
&lt;li&gt;LocalStorage&lt;/li&gt;
&lt;li&gt;完全手刻切版&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="網頁開發" scheme="https://visionyi.github.io/categories/%E7%B6%B2%E9%A0%81%E9%96%8B%E7%99%BC/"/>
    
    
      <category term="web" scheme="https://visionyi.github.io/tags/web/"/>
    
      <category term="note" scheme="https://visionyi.github.io/tags/note/"/>
    
      <category term="CSS/SCSS" scheme="https://visionyi.github.io/tags/CSS-SCSS/"/>
    
      <category term="Vue" scheme="https://visionyi.github.io/tags/Vue/"/>
    
      <category term="樣版設計" scheme="https://visionyi.github.io/tags/%E6%A8%A3%E7%89%88%E8%A8%AD%E8%A8%88/"/>
    
  </entry>
  
  <entry>
    <title>網頁切版 - 開發技巧之筆記 (持續更新)</title>
    <link href="https://visionyi.github.io/2018/04/23/%E7%B6%B2%E9%A0%81%E5%88%87%E7%89%88%20-%20%E9%96%8B%E7%99%BC%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%AD%86%E8%A8%98/"/>
    <id>https://visionyi.github.io/2018/04/23/網頁切版 - 開發技巧之筆記/</id>
    <published>2018-04-22T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.028Z</updated>
    
    <content type="html"><![CDATA[<p>從 4 月底到現在，目前持續更新當中。</p><p>這是為了讓自己的網頁切版技巧可以更加熟練，而記錄的一些心得內容，還有一些初始的開發設置，提供自己能夠更快速地上手切版技巧。</p><blockquote><p>Update date: 2018-07-15</p></blockquote><a id="more"></a><h2 id="開發前置作業"><a href="#開發前置作業" class="headerlink" title="開發前置作業"></a>開發前置作業</h2><h3 id="初始化與插件配置"><a href="#初始化與插件配置" class="headerlink" title="初始化與插件配置"></a>初始化與插件配置</h3><ul><li><p>CSS 初始化</p><ul><li><p>引入第三方初始化 CSS</p><ul><li>推薦選擇全部 margin &amp; padding 初始化 0 的</li><li>ress.css</li></ul></li><li><p>加上自訂 reset.css，必加入的配置設定 : (可加在 <code>body</code> 上)</p><ul><li>font-family</li><li>font-size</li><li>line-height</li><li>color</li><li>background-color</li><li>text-align</li></ul></li></ul></li><li><p>grid system 框架插件</p></li><li><p>UI 元件框架 (大型的)</p><ul><li>每個專案只要選一種就好</li><li>文字 &amp; 背景顏色配置</li><li>若有內置自己的 reset.css 需要多留意是否會覆蓋到自訂的配置</li><li>若有主題的 CSS 也需要多留意</li><li>若需要特別修改 CSS 屬性，可改成 <code>inherit</code> 或 <code>initial</code>，繼承最初自訂的配置</li></ul></li></ul><h3 id="開發環境建置"><a href="#開發環境建置" class="headerlink" title="開發環境建置"></a>開發環境建置</h3><ul><li>自動化任務與打包配置<ul><li>glup、webpack、Parcel</li></ul></li><li>CSS 預處理器<ul><li>SASS</li><li>PostCSS</li></ul></li><li>HTML 樣板預處理器<ul><li>pug</li><li>PostHTML</li></ul></li></ul><h2 id="頁面版面配置"><a href="#頁面版面配置" class="headerlink" title="頁面版面配置"></a>頁面版面配置</h2><h3 id="HTML-排版配置"><a href="#HTML-排版配置" class="headerlink" title="HTML 排版配置"></a>HTML 排版配置</h3><ul><li><p>優先以設計師的角度去下排版</p></li><li><p>Flex 容器排版應用</p><ol><li>使用 <code>margin-left: auto;</code> 在容器中<strong>讓子元素推移到右側</strong>，用來代替<code>float: right;</code></li><li>若容器中只有 A &amp; B 元素，A 為固定長度，使用 <code>flex: 1</code> 讓 B <strong>填滿剩餘長度</strong></li><li>於容器中<strong>讓多個子元素橫向排列</strong></li><li>於容器中<strong>讓子元素垂直置中</strong></li></ol></li><li><p>快速建置 HTML 區塊版面 - CSS 工具</p></li></ul><h3 id="RWD-版面配置"><a href="#RWD-版面配置" class="headerlink" title="RWD 版面配置"></a>RWD 版面配置</h3><ul><li>使用 <strong>網格系統排版</strong> + 顯示與隱藏的斷點切換</li></ul><h3 id="CSS-Class-樣式命名的配置"><a href="#CSS-Class-樣式命名的配置" class="headerlink" title="CSS Class 樣式命名的配置"></a>CSS Class 樣式命名的配置</h3><ul><li><p>搭配 CSS / SASS 設計模式規範</p><ul><li>SMACSS</li><li>OOCSS</li><li>BEM (推薦)<ul><li><a href="https://www.smashingmagazine.com/2016/06/battling-bem-extended-edition-common-problems-and-how-to-avoid-them/" target="_blank" rel="noopener">Battling BEM CSS: 10 Common Problems And How To Avoid Them</a></li></ul></li><li>MVCSS</li></ul></li><li><p>若有加入大型的 UI 元件框架，自訂的 CSS 樣式名稱需要加入自己的<strong>前綴符號</strong>，可避免與框架的 CSS 樣式名稱衝突或被覆蓋</p></li><li><p>若要修改 UI 元件的 CSS 內容，最好的處裡方式為</p><ul><li>需要先擁有自訂的 CSS 樣式</li><li>CSS 撰寫類似如下 2 種，能明確增加 CSS 權重去覆蓋，如果還覆蓋不了就代表此 UI 元件的 CSS 權重值非常糟糕</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 有明確指定的 UI 元件時適用 */</span></span><br><span class="line"><span class="selector-class">.self-class</span> <span class="selector-class">.ui-component-class</span> &#123;</span><br><span class="line">  <span class="attribute">properties</span>: xxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 同時有多個相同的 UI 元件，卻要套用不同的自訂樣式時適用 */</span></span><br><span class="line"><span class="selector-class">.self-type1-class</span><span class="selector-class">.ui-component-class</span> &#123;</span><br><span class="line">  <span class="attribute">properties</span>: xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加使用者體驗"><a href="#增加使用者體驗" class="headerlink" title="增加使用者體驗"></a>增加使用者體驗</h3><ul><li>a &amp; button 標籤的 hover 顯示</li><li>Loading 狀態過程顯示</li><li>頁面全體遮罩 (在操做流程中適當的加入，可以避免一些問題)</li><li>Dialog Message 跳出訊息</li></ul><h3 id="無障礙標籤配置"><a href="#無障礙標籤配置" class="headerlink" title="無障礙標籤配置"></a>無障礙標籤配置</h3><blockquote><p><em>待新增…</em></p></blockquote><h2 id="CSS-屬性架構"><a href="#CSS-屬性架構" class="headerlink" title="CSS 屬性架構"></a>CSS 屬性架構</h2><ul><li><p><a href="https://ithelp.ithome.com.tw/articles/10196454" target="_blank" rel="noopener">CSS 權重 (css specificity)</a></p></li><li><p>使用 rem 單位，隨著根字體大小而自動改變，預設為 16px (<a href="https://webdesign.tutsplus.com/zh-hans/tutorials/comprehensive-guide-when-to-use-em-vs-rem--cms-23984" target="_blank" rel="noopener">參考網址</a>)</p><ul><li>font-size</li><li>width</li><li>height</li><li>margin</li><li>padding</li><li>border-radius</li><li>shadows</li></ul></li><li><p>使用 em 單位，隨著當下字體大小而自動改變，使用時機為 :</p><ul><li>單一元素或小型元件的<strong>文字內容不是使用默認根字體大小時</strong></li><li>此元素或元件可以<strong>有多種的字體大小時</strong></li><li>此元素或元件的大小是<strong>以字體大小的比例做縮放時</strong></li></ul></li><li><p>若設計的內容無背景或邊框線條，需要加上間距 (邊距) 時</p><ul><li>使用 margin 優先於 padding</li><li>使用單邊優先於雙邊</li><li>單邊優先使用 margin-bottom 或 margin-right</li></ul></li></ul><h2 id="SCSS-架構"><a href="#SCSS-架構" class="headerlink" title="SCSS 架構"></a>SCSS 架構</h2><h3 id="基本檔案目錄"><a href="#基本檔案目錄" class="headerlink" title="基本檔案目錄"></a>基本檔案目錄</h3><ul><li><p><strong><code>_variables.scss</code></strong></p><ul><li>包含所有的變數與設定內容</li></ul></li><li><p><strong><code>_mixins.scss</code></strong></p><ul><li>包含 @mixin、@extend、@function 之類的</li></ul></li><li><p><strong><code>_reset.scss</code></strong></p><ul><li>初始化頁面基本元素，把所有預設值重置</li><li>可加入第三方 reset CSS - <a href="https://github.com/filipelinhares/ress" target="_blank" rel="noopener">ress.css</a></li><li>加入自訂的預設值</li></ul></li><li><p><strong><code>_base.scss</code></strong></p><ul><li>elements &amp; structure (layout) 單一元素或結構外框之類的</li><li>專案變大時，以資料夾分出多個檔案</li></ul></li><li><p><strong><code>_components.scss</code></strong></p><ul><li>元件，大部份都會是搭配 JS 的類型</li><li>專案變大時，以資料夾分出多個檔案</li></ul></li><li><p><strong><code>_helpers.scss</code></strong></p><ul><li>增加元素或元件的附加屬性，例: 背景大小、間距、位置型態之類的</li><li>CSS class 多為單一屬性內容</li></ul></li><li><p><strong><code>main.scss</code></strong></p><ul><li>@import 以上所有 scss/sass 檔案</li></ul></li></ul><h3 id="Variables-必要的變數"><a href="#Variables-必要的變數" class="headerlink" title="Variables 必要的變數"></a>Variables 必要的變數</h3><ul><li><p>文字大小</p><ul><li>小字至少 1 種</li><li>原始大小 1 種</li><li>大字至少 3 種</li></ul></li><li><p>間距 (邊距) 大小</p><ul><li>總共至少 3 種 ~ 5 種</li></ul></li><li><p>顏色</p><ul><li><strong>文字</strong>顏色</li><li><strong>背景</strong>顏色</li><li><strong>邊框線條</strong>顏色</li><li><strong>主題色彩</strong>顏色，像是 primary、info、success、warning、danger</li></ul></li><li><p>madia query 斷點範圍</p></li></ul><h3 id="可做成-Helpers-的樣式種類-需加上-important"><a href="#可做成-Helpers-的樣式種類-需加上-important" class="headerlink" title="可做成 Helpers 的樣式種類 (需加上 ! important)"></a>可做成 Helpers 的樣式種類 (需加上 ! important)</h3><ul><li><p>間格距離、分隔空間之類的</p><ul><li>內外邊距 - <code>margin</code> 或 <code>padding</code></li><li>例如: <code>margin-buttom: xxx</code> =&gt; <code>mb-x</code> 樣式名稱</li></ul></li><li><p>顏色</p><ul><li>背景 - <code>background-color</code></li><li>文字 - <code>color</code></li><li>邊框 - <code>border-color</code></li></ul></li><li><p>文字類型</p><ul><li>大小 - <code>font-size</code> + <code>line-weight</code></li><li>粗細 - <code>font-weight</code></li><li>斜體字 - <code>font-style: italic</code></li><li>底線 - <code>text-decoration: underline</code></li><li>基本顏色之明亮或黯淡 - <code>color</code></li></ul></li><li><p>元素的顯示方式</p><ul><li>垂直置中 - <code>display: flex</code> + <code>algin-items</code> 或 <code>justify-content</code></li><li>RWD 之元素的顯示或隱藏</li></ul></li></ul><h3 id="顏色架構-懶人包-以下為淡色系為主"><a href="#顏色架構-懶人包-以下為淡色系為主" class="headerlink" title="顏色架構 (懶人包) - 以下為淡色系為主"></a>顏色架構 (懶人包) - 以下為淡色系為主</h3><h4 id="文字顏色-由深到淺"><a href="#文字顏色-由深到淺" class="headerlink" title="文字顏色 - 由深到淺"></a>文字顏色 - 由深到淺</h4><ul><li>主顏色範圍: <code>#000000</code> ~ <code>#333333</code></li><li>lighten(主顏色 , 25%)</li><li>lighten(主顏色 , 35%)</li></ul><h4 id="邊框線條顏色-由深到淺"><a href="#邊框線條顏色-由深到淺" class="headerlink" title="邊框線條顏色 - 由深到淺"></a>邊框線條顏色 - 由深到淺</h4><ul><li><p>主顏色範圍: <code>bga(176, 176, 176) #B0B0B0</code> ~ <code>bga(201, 201, 201) #C9C9C9</code></p><ul><li>rbg 3 個值相加介於 528 ~ 603 之間</li><li>每個數值介於 151 ~ 226 之間</li></ul></li><li><p>lighten(主顏色 , 10%)</p></li><li>lighten(主顏色 , 14%) <strong>最高值</strong>: <code>#EDEDED</code></li></ul><h4 id="背景顏色-由深到淺"><a href="#背景顏色-由深到淺" class="headerlink" title="背景顏色 - 由深到淺"></a>背景顏色 - 由深到淺</h4><ul><li><p>主顏色範圍: <code>bga(219, 219, 219) #DBDBDB</code> ~ <code>bga(232, 232, 232) #E8E8E8</code></p><ul><li>rbg 3 種值相加介於 657 ~ 696 之間</li><li>每個數值介於 206 ~ 245 之間</li></ul></li><li><p>lighten(主顏色 , 5%)</p></li><li><p>lighten(主顏色 , 8%) <strong>最高值</strong>: <code>#FAFAFA</code></p></li><li><p>計算公式:</p><ul><li>先定義出<strong>最高值</strong> A 與主顏色亮度會提高 x% &amp; y%，再定義 z% 的區間範圍 (此範例為 x=5, y=8, z=5)</li><li>選色範圍: darken(A, y% + z%) ~ darken(A, y%)</li><li>每個數值介於 (最低範圍值 - 範圍相差值) ~ (最高範圍值 + 範圍相差值)</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;從 4 月底到現在，目前持續更新當中。&lt;/p&gt;
&lt;p&gt;這是為了讓自己的網頁切版技巧可以更加熟練，而記錄的一些心得內容，還有一些初始的開發設置，提供自己能夠更快速地上手切版技巧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Update date: 2018-07-15&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="網頁開發" scheme="https://visionyi.github.io/categories/%E7%B6%B2%E9%A0%81%E9%96%8B%E7%99%BC/"/>
    
    
      <category term="web" scheme="https://visionyi.github.io/tags/web/"/>
    
      <category term="note" scheme="https://visionyi.github.io/tags/note/"/>
    
      <category term="CSS/SCSS" scheme="https://visionyi.github.io/tags/CSS-SCSS/"/>
    
      <category term="樣版設計" scheme="https://visionyi.github.io/tags/%E6%A8%A3%E7%89%88%E8%A8%AD%E8%A8%88/"/>
    
  </entry>
  
  <entry>
    <title>Vue Learning 學習筆記 (已結束更新)</title>
    <link href="https://visionyi.github.io/2018/03/05/vue-learning-note/"/>
    <id>https://visionyi.github.io/2018/03/05/vue-learning-note/</id>
    <published>2018-03-04T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.027Z</updated>
    
    <content type="html"><![CDATA[<p>這是從今年 3 月初開始學習 Vue 的相關技術到現在，目前已更新結束。</p><p>體驗的過程中採了不少坑，嘗試導入各個專案中，希望可以建立更完整的 SPA 網站，因此記錄的一些心得內容都放在這裡了，提供未來的自己可以更快速地開發專案，運用 Vue 建立更完善與維護性高的網頁服務。</p><blockquote><p>Update date: 2018-07-26</p></blockquote><a id="more"></a><h3 id="主要學習的技術領域"><a href="#主要學習的技術領域" class="headerlink" title="主要學習的技術領域"></a>主要學習的技術領域</h3><ul><li>Vue v2.x</li><li>vue-cli v3.x 環境建置手腳架</li><li>vue-router 前端路由操作</li><li>vuex + axios 狀態與共用資料的管理 + 處理 HTTP 請求服務</li><li>Vuetify UI 組件框架</li></ul><h3 id="vue-生命週期-mounted-的使用時機"><a href="#vue-生命週期-mounted-的使用時機" class="headerlink" title="vue 生命週期 mounted 的使用時機"></a>vue 生命週期 mounted 的使用時機</h3><ul><li><p>瀏覽器進行以下階段時，將調用此函數鉤子</p><ul><li>當頁面所有 DOM 元素都第一次渲染完成</li><li>vue 的所有實例資料掛載完成後</li></ul></li><li><p>在此進行以下操作</p><ul><li>執行 ajax 資料請求</li><li>執行資料初始化，包含 Vuex store 的 資料狀態</li><li>取得 <code>vm.$refs</code>、<code>window</code>、<code>document</code> 之 DOM 元素，執行資料初始化</li><li>執行全局的 <code>window</code> 監聽事件 scroll, resize 之類的</li></ul></li><li><p>參考 : <a href="https://segmentfault.com/a/1190000008570622" target="_blank" rel="noopener">關於 Vue 實例的生命週期 created &amp; mounted 的區別</a></p></li></ul><h3 id="src-中的目錄架構，另外加上-3-個資料夾"><a href="#src-中的目錄架構，另外加上-3-個資料夾" class="headerlink" title="src 中的目錄架構，另外加上 3 個資料夾"></a>src 中的目錄架構，另外加上 3 個資料夾</h3><ul><li>api 目錄: 後端 api 的實作或反向校驗後端 api 的方法</li><li>service 目錄: 處理後端 api 請求後的 Data，整合後再統一給 store</li><li>shared / util 目錄: 一些共用的 library、自製的函數方法、常數設定…等等</li><li>參考: <a href="https://github.com/berwin/Blog/issues/14" target="_blank" rel="noopener">Vue 項目架構設計與工程化實踐</a></li></ul><h3 id="Vue-Components-組件"><a href="#Vue-Components-組件" class="headerlink" title="Vue Components 組件"></a>Vue Components 組件</h3><ul><li>將所有的 components 集中導向到同一個 index.js 接口</li><li>之後再到 src/main.js 一起輸出成 <code>Vue.component(key, value)</code>，這樣所有的 view 就能直接引用了</li></ul><h3 id="輔助工具"><a href="#輔助工具" class="headerlink" title="輔助工具"></a>輔助工具</h3><ul><li>使用 <a href="https://browsersync.io/" target="_blank" rel="noopener">browser-sync</a> 做一個簡易的 server，把已建置完成的 dist 靜態檔案放上去</li><li>使用 <a href="https://github.com/typicode/json-server" target="_blank" rel="noopener">json-server</a> 建構後端 REST API，將資料庫建在記憶體中的方法</li><li>使用 <a href="https://www.npmjs.com/package/gh-pages" target="_blank" rel="noopener">gh-pages - npm</a> 佈署發布到 Github Page 上</li></ul><h3 id="把-axios-api-封裝成-request-js"><a href="#把-axios-api-封裝成-request-js" class="headerlink" title="把 axios api 封裝成 request.js"></a>把 axios api 封裝成 request.js</h3><ul><li>可加入額外的設定條件</li><li>可事先攔截 request 的內容，加入 Authentication 或限制條件之類的，再傳給後端</li><li>可事先攔截 response 的內容，做一些資料的邏輯修改再回傳</li><li>可事先統一處理 error 事件的產生，例: 發出錯誤訊息、轉跳網址之類的</li><li>可以把 data 改成 <strong>POST 表單形式</strong>再傳給後端<ul><li>參考: <a href="https://segmentfault.com/q/1010000008462977" target="_blank" rel="noopener">axios發送post請求，如何提交表單數據</a></li></ul></li><li>參考: <a href="https://xiaozhuanlan.com/topic/8295076341" target="_blank" rel="noopener">Axios 封裝(報錯,鑑權,跳轉,攔截,提示)</a></li></ul><h3 id="vuex-store-使用技巧"><a href="#vuex-store-使用技巧" class="headerlink" title="vuex store 使用技巧"></a>vuex store 使用技巧</h3><ul><li><p>哪時候可以使用</p><ul><li>不同的組件或 view 需要<strong>共用的資料或狀態</strong>時可用</li><li><strong>最主要串接 API 的資料</strong>請一定要放入，不時就可能會出現相關聯的狀態或資料參考的~</li><li>不想隨著切換頁面一直重載的<strong>大筆數的資料</strong></li><li>統一管理資料用也行</li></ul></li><li><p>mutations 的使用時機</p><ul><li><strong>操作單一的資料內容時</strong></li><li>set、add (<code>arr.push()</code>)、update、delete 之類的操作</li></ul></li><li><p>actions 的使用時機</p><ul><li><strong>處理資料的商業邏輯時</strong></li><li><strong>處理非同步事件</strong></li></ul></li><li><p>store 撰寫思考順序</p><ul><li>state —&gt; getters —&gt; mutations (set) —&gt;  actions —&gt; mutations (add, update, delete)</li></ul></li><li><p>修改資料狀態的 JS 使用方式 (為了讓 vue 能夠檢測到更新 DOM)</p><ul><li>陣列新增項目：<ul><li><code>arr.push(newItem)</code></li><li><code>arr.push({ props: value })</code></li></ul></li><li><p>陣列修改項目：</p><ul><li><code>arr.splice(index, 1, newItem)</code></li><li><code>arr.splice(arr.indexOf(oldItem), 1, { ...oldItem, props: value })</code></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> index = arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item.id === id);</span><br><span class="line">arr.splice(index, <span class="number">1</span>, &#123; ...arr[index], <span class="attr">props</span>: value &#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>陣列刪除項目：</p><ul><li><code>arr.splice(index, 1)</code></li><li><code>arr.splice(arr.indexOf(oldItem), 1)</code></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> index = arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item.id === id);</span><br><span class="line">arr.splice(index, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>物件新增 / 修改屬性內容：</p><ul><li><code>obj = {...obj, props: value}</code></li></ul></li><li>物件新增 / 修改多個屬性內容：<ul><li><code>obj = {...obj, ...objData}</code></li><li><code>obj = {...obj, ...{ p1: v1, p2: v2 } }</code></li></ul></li></ul></li><li><p>可使用 vuex modules 系統，其中參數 namespaced 設置為 true，就能把資料做成模組分類</p></li></ul><h3 id="vue-directives-的使用時機"><a href="#vue-directives-的使用時機" class="headerlink" title="vue.directives 的使用時機"></a>vue.directives 的使用時機</h3><ul><li><p>函數鉤子 <code>bind</code> :</p><ul><li>當指令被綁定到 DOM 元素時調用，初始化設置用</li><li>基本上使用以下 <code>inserted</code> 函數鉤子來代替使用就行了</li></ul></li><li><p>函數鉤子 <code>inserted</code> :</p><ul><li>當 DOM 元素被綁定與渲染完成後調用 (被 vue 插入節點中時調用)</li><li>可用於全局 window 監聽事件來綁定 DOM 元素的操作，參數值可以是函數</li></ul></li><li><p>函數鉤子 <code>unbind</code> :</p><ul><li>當 DOM 元素被 vue 從節點中移除時調用</li></ul></li><li><p>函數鉤子 <code>update</code> :</p><ul><li>當所在的組件任一 DOM 元素更新渲染時會調用</li><li>如果想要<strong>隨著 資料(Data) 或 狀態(status) 的變化去更新 DOM 元素時</strong>，這就非常好用</li><li>由於 <code>binding.value</code> 沒變動有時也會執行，可以通過比較 <code>binding.oldValue</code> 來過濾不必要的更新執行</li></ul></li><li><p>缺點 :</p><ul><li><del>無法使用 <code>this</code> (vue 實例)，所有的 data 都只能從參數值傳進來，所取得的參數除了 el 其他都只能是唯讀的</del>，<em>請看進階用法</em></li></ul></li><li><p>進階用法:</p><ul><li>參數值可以是一個函數，使用 directive 取得的值帶入此函數方法，類似閉包方式，此函數內就能使用 <code>this</code> (vue 實例)了</li></ul></li></ul><h3 id="vue-的動畫-amp-元素轉場操作"><a href="#vue-的動畫-amp-元素轉場操作" class="headerlink" title="vue 的動畫 &amp; 元素轉場操作"></a>vue 的動畫 &amp; 元素轉場操作</h3><ul><li>使用 <code>&lt;transition&gt;</code> 標籤</li><li>加上 appear 屬性可以在初始化渲染後馬上執行動畫效果</li></ul><h3 id="登入系統概念"><a href="#登入系統概念" class="headerlink" title="登入系統概念"></a>登入系統概念</h3><ul><li><p>加上 Token 認證機制</p></li><li><p>需要使用 localStorage 或 cookies 儲存 token，可讓其他子網域自動認證/自動登入，也可以加入 expire 過期機制</p></li><li><p>可以創建 auth.js 專門處理 登入、登出、註冊 的邏輯概念</p></li><li><p>完整實踐概念:</p><ol><li>前端 component - 處理畫面的狀態與資料顯示<ul><li>loading 狀態</li><li>response message 顯示</li><li>成功後觸發 url 轉跳</li></ul></li><li>前端 vuex store - 處理元件之間的共用資料與暫存資料<ul><li>獲取 user 基本資料</li><li>獲取 token、登入或登出時間</li><li>使用 localStorage 或 cookies 暫存</li><li>抓取第三方 api 服務的資料</li><li>敏感資料處理/編碼</li></ul></li><li>後端 - 操作資料庫的邏輯與處理驗證資料<ul><li>查詢 user 是否存在</li><li>修改登入或登出狀態、時間、身分…等等</li><li>驗證 token、敏感資料解碼</li><li>回傳是否成功，回傳資料: result data 或 failure message</li></ul></li><li>前端 router - 判斷使 url 轉跳為登入頁面<ul><li>當敏感頁面需要登入驗證時轉跳</li><li>當發現登入 token 過期時轉跳</li></ul></li></ol></li></ul><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><ul><li>改成動態加載的方式，避免名稱或邏輯衝突</li></ul><h3 id="sass-scss-撰寫"><a href="#sass-scss-撰寫" class="headerlink" title="sass/scss 撰寫"></a>sass/scss 撰寫</h3><ul><li>如果是使用 vue-cli v3.x 建置初始的樣版</li><li>可以配置全局的 SCSS 自動載入，在 vue.config.js 檔案中配置如下</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      sass: &#123;</span><br><span class="line">        <span class="comment">// 自動載入常用的檔案，例: 全局變數、常用函數</span></span><br><span class="line">        data: <span class="string">'@import "@/your_path/_variables.scss"; @import "@/your_path/_mixins.scss";'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這是從今年 3 月初開始學習 Vue 的相關技術到現在，目前已更新結束。&lt;/p&gt;
&lt;p&gt;體驗的過程中採了不少坑，嘗試導入各個專案中，希望可以建立更完整的 SPA 網站，因此記錄的一些心得內容都放在這裡了，提供未來的自己可以更快速地開發專案，運用 Vue 建立更完善與維護性高的網頁服務。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Update date: 2018-07-26&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="網頁開發" scheme="https://visionyi.github.io/categories/%E7%B6%B2%E9%A0%81%E9%96%8B%E7%99%BC/"/>
    
    
      <category term="web" scheme="https://visionyi.github.io/tags/web/"/>
    
      <category term="note" scheme="https://visionyi.github.io/tags/note/"/>
    
      <category term="Vue" scheme="https://visionyi.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript ES6 重點紀錄系列 總集</title>
    <link href="https://visionyi.github.io/2018/01/25/ES6-series0-all/"/>
    <id>https://visionyi.github.io/2018/01/25/ES6-series0-all/</id>
    <published>2018-01-24T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.023Z</updated>
    
    <content type="html"><![CDATA[<p>這個系列是為了可以成為更好的前端工程師，所需要有的 JavaScript 技能，我把這些研究的重點都記錄下來了。</p><p>ES6 從推出到現在已經過蠻久了，應用上也很成熟了，在許多 JS 前端或後端框架上都能普遍看到它的身影。將來寫 JS 不管是前端還是後端，ES6 這些新特性真的是必備的技能了，所以事先好好地深入學習是必要的。</p><a id="more"></a><h2 id="先來看看什麼是-JavaScript-ES6"><a href="#先來看看什麼是-JavaScript-ES6" class="headerlink" title="先來看看什麼是 JavaScript ES6"></a>先來看看什麼是 JavaScript ES6</h2><p>ES6 的完整名稱為 <strong>ECMAScript 6</strong> ，這是 JavaScript 語言新一代的<strong>標準規範</strong>，在 2015 年 6 月正式發佈。</p><p>ES6 其實是一個泛指的名詞，泛指 ES5.1 版以後的新一代 JavaScript 語言標準，涵蓋了 ES2015, ES2016, ES2017 等等，ECMAScript 2015 (簡稱 ES2015) 則是正式名稱，特別算是該年度發佈的語言標準，也就是 ES6 語言標準。</p><p>ES6 提出了許多新的語法與特性，甚至擴充更多 API 可以更容易使用，使得 JavaScript 變得更強大，更適合用來寫大型或複雜的應用程式！</p><h2 id="重點記錄-系列目錄"><a href="#重點記錄-系列目錄" class="headerlink" title="重點記錄 - 系列目錄"></a>重點記錄 - 系列目錄</h2><h3 id="語法的新特性"><a href="#語法的新特性" class="headerlink" title="語法的新特性"></a>語法的新特性</h3><ul><li><a href="/2017/12/23/ES6-series1-let-const/">ES6 宣告方式 let、const</a></li><li><a href="/2017/12/26/ES6-series2-Destructuring-Assignment/">ES6 解構賦值 Destructuring Assignment</a></li><li><a href="/2017/12/30/ES6-series3-for-of/">ES6 取值迴圈 for…of</a></li><li><a href="/2018/01/01/ES6-series4-template-literals/">ES6 樣板文字串 Template literals</a></li><li><a href="/2018/01/02/ES6-series5-spread-operator/">ES6 擴展運算子 Spread Operator</a></li><li><a href="/2018/01/04/ES6-series6-func-default-parameters-rest/">ES6 函數中的預設參數 &amp; Rest 參數</a></li><li><a href="/2018/01/05/ES6-series7-arrow-function/">ES6 箭頭函數 Arrow Function</a></li><li><a href="/2018/01/06/ES6-series8-object-syntax-sugar-expansion/">ES6 物件語法糖的擴展</a></li></ul><h3 id="新的-API-語法"><a href="#新的-API-語法" class="headerlink" title="新的 API 語法"></a>新的 API 語法</h3><ul><li><a href="/2018/01/07/ES6-series9-class/">ES6 class 類別語法</a></li><li><a href="/2018/01/10/ES6-series10-symbol/">ES6 Symbol 資料類型</a></li><li><a href="/2018/01/11/ES6-series11-map/">ES6 Map 物件</a></li><li><a href="/2018/01/12/ES6-series12-module-system/">ES6 Module System 模組系統</a></li><li><a href="/2018/01/13/ES6-series13-api-other-expansion/">ES6 其他的 API 與特性擴展</a></li></ul><h3 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h3><ul><li><a href="/2018/01/20/ES6-series14-build-dev-babel/">ES6 開發環境建置(上) - Babel 編譯工具</a></li><li><a href="/2018/01/21/ES6-series15-build-dev-eslint/">ES6 開發環境建置(下) - ESLint 偵錯工具</a></li></ul><h2 id="其他實用網站記錄"><a href="#其他實用網站記錄" class="headerlink" title="其他實用網站記錄"></a>其他實用網站記錄</h2><p>以下都是我在研究學習期間所收集的實用網站，有些內容真的很不錯，都可以點點看 :</p><ul><li><p>線上網頁程式碼預覽 &amp; 編輯 (支援 ES6)</p><ul><li><a href="https://codepen.io/" target="_blank" rel="noopener">CodePen</a></li><li><a href="https://jsbin.com/?html,js,output" target="_blank" rel="noopener">JS - Bin</a></li><li><a href="https://jsfiddle.net/" target="_blank" rel="noopener">JSFiddle</a></li><li><a href="https://plnkr.co/" target="_blank" rel="noopener">Plunker</a></li></ul></li><li><p>瀏覽器支援度查尋工具</p><ul><li><a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">ECMAScript6 compatibility table</a></li><li><a href="https://caniuse.com/" target="_blank" rel="noopener">Can I use… Support tables </a></li></ul></li><li><p>其他實用工具</p><ul><li><a href="http://es6-features.org" target="_blank" rel="noopener">ECMAScript 6 — New Features: Overview &amp; Comparison</a></li><li><a href="https://babeljs.io/repl/" target="_blank" rel="noopener">Babel · The compiler for writing next generation JavaScript</a></li></ul></li><li><p>文章參考資源</p><ul><li><a href="https://medium.com/@peterchang_82818/es6-10-features-javasfcript-developer-must-know-98b9782bef44" target="_blank" rel="noopener">Javascript 開發者必須知道的 10 個新功能</a></li><li><a href="http://es6.ruanyifeng.com/?search=%24%7B%7D&amp;x=0&amp;y=0#README" target="_blank" rel="noopener">ECMAScript 6 入門</a></li><li><a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/" target="_blank" rel="noopener">從ES6開始的JavaScript學習生活</a></li><li><a href="https://ponyfoo.com/articles/tagged/es6-in-depth" target="_blank" rel="noopener">ES6 in Depth</a></li><li><a href="https://www.fooish.com/javascript/es6/" target="_blank" rel="noopener">JavaScript ES6 介紹 - JavaScript (JS) 教學 Tutorial</a></li><li><a href="https://ponyfoo.com/articles/javascript-developer-survey-results#do-you-write-tests" target="_blank" rel="noopener">JavaScript Developer Survey Results</a></li></ul></li></ul><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>其實在研究這些內容期間都斷斷續續的，所以拖了這麼久才完成它，有些網站又寫得非常棒，很不想再重複寫一次阿，但還是自己整理記錄一次，以後想回頭瞭解也比較有方向吧！</p><p>當然在 ES6 中還有蠻多東西可以介紹的，甚至是 ES7 新的 API 語法 <strong>async函數 &amp; await</strong>，這基本上能夠代替 ES6 的 Promise 物件來處理 JavaScript 非同步事件了，新的事物一直發展出來真的很厲害，學習的道路還要繼續不斷地往前走。</p><p>雖然寫文章真的蠻累的，至少一路走來，檢視到自己的成長與努力是值得的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這個系列是為了可以成為更好的前端工程師，所需要有的 JavaScript 技能，我把這些研究的重點都記錄下來了。&lt;/p&gt;
&lt;p&gt;ES6 從推出到現在已經過蠻久了，應用上也很成熟了，在許多 JS 前端或後端框架上都能普遍看到它的身影。將來寫 JS 不管是前端還是後端，ES6 這些新特性真的是必備的技能了，所以事先好好地深入學習是必要的。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6-重點紀錄" scheme="https://visionyi.github.io/categories/ES6-%E9%87%8D%E9%BB%9E%E7%B4%80%E9%8C%84/"/>
    
    
      <category term="JavaScript" scheme="https://visionyi.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://visionyi.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 開發環境建置(下) - ESLint 偵錯工具</title>
    <link href="https://visionyi.github.io/2018/01/21/ES6-series15-build-dev-eslint/"/>
    <id>https://visionyi.github.io/2018/01/21/ES6-series15-build-dev-eslint/</id>
    <published>2018-01-20T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.024Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇 <a href="/2018/01/20/ES6-series14-build-dev-babel/">ES6 開發環境建置(上) - Babel 編譯工具</a> 講解 Babel 後，這篇將來介紹 ESLint ，使用 <strong>ESLint 偵錯工具</strong>來<strong>檢查 JavaScript 靜態程式碼的語法和風格</strong>，讓我們在編譯前可以減少錯誤產生，還能改善程式碼的品質與統一程式碼風格。</p><a id="more"></a><p>在使用前可以先建置環境目錄，有需求的請參考上一篇的第一段內容。</p><h2 id="使用-ESLint-偵錯工具"><a href="#使用-ESLint-偵錯工具" class="headerlink" title="使用 ESLint 偵錯工具"></a>使用 ESLint 偵錯工具</h2><p><img src="https://i.imgur.com/0XlkrTV.png" alt="ESLint-logo"></p><p>為了讓 Babel 編譯器能順利執行，避免錯誤的產生，也讓我們有更好的程式碼品質，減少後續維護的成本，<a href="https://eslint.org/" target="_blank" rel="noopener">ESLint</a> 就是個非常適合的偵錯工具使用在 JavaScript 語言上，它也支援 ES6 最新的標準，不過ESLint 的配置規範就比較複雜一些，最好搭配主流的規範套件會比較輕鬆。</p><h3 id="工具說明"><a href="#工具說明" class="headerlink" title="工具說明"></a>工具說明</h3><h4 id="eslint-工具"><a href="#eslint-工具" class="headerlink" title="eslint 工具"></a><code>eslint</code> 工具</h4><ul><li>ESLint 本身的工具，內建就可以執行命令行了</li><li>需要安裝在全域環境下才能使用 <code>eslint</code> 命令</li><li>基本用法如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 初始化建立 .eslintrc 配置檔</span><br><span class="line">eslint --init</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 偵測目標檔案是否有違反規範 (需先建立配置檔)</span><br><span class="line">eslint example.js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 偵測完若有錯誤，將會自動修復不符規範的地方</span><br><span class="line">babel example.js --fix</span><br></pre></td></tr></table></figure><h4 id="eslintrc-配置檔"><a href="#eslintrc-配置檔" class="headerlink" title=".eslintrc 配置檔"></a><code>.eslintrc</code> 配置檔</h4><ul><li>ESLint 的規範內容都會在這裡設置，可自行設定規範需求</li><li>主要都是使用 JSON 格式，規範內容可參考 <a href="https://denny.qollie.com/2016/07/11/eslint-fxcking-setup/#Configuration-of-ESLint" target="_blank" rel="noopener">淺入淺出 eslint 與實作-Configuration of ESLint</a></li><li>基本格式如下</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "parser": "",         // 預設解析器</span><br><span class="line">  "parserOptions": &#123;&#125;,  // 預設解析器的設定</span><br><span class="line">  "extends": [],        // 可引入其他完整的配置檔</span><br><span class="line">  "plugins": [],        // 可引入第三方套件</span><br><span class="line">  "env": &#123;&#125;,            // 設定環境，會有不同的全域變數，像是 browser、node</span><br><span class="line">  "globals": &#123;&#125;,        // 可自訂加入全域變數</span><br><span class="line">  "rules": &#123;&#125;           // 可自訂加入規範內容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="開始實際建置"><a href="#開始實際建置" class="headerlink" title="開始實際建置"></a>開始實際建置</h3><p><strong>1.</strong> 為了方便使用，在本地端與全域環境中都安裝 <code>eslint</code> 工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install eslint -g</span><br><span class="line"><span class="meta">$</span> npm install eslint --save-dev</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 在根目錄下初始化，建立<code>.eslintrc</code>配置檔</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> eslint --init</span><br></pre></td></tr></table></figure><p><strong>3.</strong> 這裡會先問你要怎麼建立規範檔案呢? 如下 :</p><ul><li>Answer questions about your style</li><li>Use a popular style guide</li><li>Inspect your JavaScript file(s)</li></ul><p>通常只會選擇前兩種方式。如果選擇第一項，將會一連串問你基本的規範內容，選擇 JSON 格式，就會直接建立<code>.eslintrc.json</code>配置檔。</p><p>不過，最常用的還是使用第二項，引入主流的規範配置，順便會再問你想要哪一種主流規範，這裡會使用 “<strong><a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">Airbnb</a></strong>“ 為居多，也很適合團隊的規範，點選完後會幫你下載它的專屬配置套件，再幫你建立<code>.eslintrc.json</code>配置檔，ESLint 會把這個主流規範自動引入配置檔中。(這裡不選擇把 react 加入)</p><p><strong>4.</strong> <code>.eslintrc.json</code>檔案內容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: <span class="string">"airbnb-base"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 npm 的<code>packing.json</code>配置檔中你會看到多了剛剛下載的套件，代表安裝成功了，如下 :</p><blockquote><p>“devDependencies”: {<br>  “eslint”: “^4.15.0”,<br>  “eslint-config-airbnb-base”: “^12.1.0”,<br>  “eslint-plugin-import”: “^2.8.0”<br>}</p></blockquote><p><strong>5.</strong> 接下來就可以加入自訂的規範內容，改寫<code>.eslintrc.json</code>配置檔</p><ul><li>這裡舉例: <strong>縮排使用4個空格、允許使用 <code>console.log()</code>、加入環境設定 browser</strong></li><li><code>.eslintrc.json</code>以舉例來說，內容改寫成如下</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: <span class="string">"airbnb-base"</span>,</span><br><span class="line">  <span class="attr">"env"</span>: &#123;</span><br><span class="line">    <span class="attr">"browser"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"rules"</span>:&#123;</span><br><span class="line">    <span class="attr">"indent"</span>: [<span class="string">"error"</span>, <span class="number">4</span>],</span><br><span class="line">    <span class="attr">"no-console"</span>: <span class="string">"off"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6.</strong> 最後就能偵錯檔案了，終端機執行命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> eslint src/index.js</span><br></pre></td></tr></table></figure><p>然後運行後的結果，將會幫你列出不符合規範的地方，若有錯誤，結果類似下圖 :<br><img src="https://i.imgur.com/1injs6c.png" alt="運行後結果圖"></p><p>以上就是 ESLint 的基本使用，當然自己手動偵錯是很笨的方式，一樣這也可以搭配第三方套件來幫你自動偵錯。</p><p><strong>7.</strong> 搭配<strong>自動化模組工具</strong>或<strong>程式編輯器的插件</strong></p><ul><li>自動化模組工具可以使用 Webpack</li><li>最好還是使用程式編輯器的插件來輔助會比較方便，這裡以 VSCode 編輯器為例<ul><li>安裝 ESLint 插件如下圖</li><li>使用 npm 安裝全域環境<code>eslint</code>，再依照步驟建立好<code>.eslintrc.json</code>規範後就可以使用啦！</li></ul></li></ul><p><img src="https://i.imgur.com/YK16NyK.png" alt="VSCode 插件 ESLint"></p><p>只要搭配好的工具就能讓你輕鬆偵錯，快速建立環開發境，改善你的 coding style，尤其是在團隊裡更應該要有好的規範習慣。</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>這篇做的有點久阿，原因網路上許多教學都很簡略就帶過了，我想做個完整地操作步驟，至少要知道這些工具是如何被使用，再來搭配其他套件工具也是很重要的。</p><p>原本 “<strong>ES6 開發環境建置</strong>“ 是打算只用一篇發出，但寫到最後改了很多次，又加深說明，導致內容不知不覺暴增…所以就分為兩篇文章介紹了，希望可以達到最完整的紀錄，清楚知道這些工具在使用上是很方便的啦~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇 &lt;a href=&quot;/2018/01/20/ES6-series14-build-dev-babel/&quot;&gt;ES6 開發環境建置(上) - Babel 編譯工具&lt;/a&gt; 講解 Babel 後，這篇將來介紹 ESLint ，使用 &lt;strong&gt;ESLint 偵錯工具&lt;/strong&gt;來&lt;strong&gt;檢查 JavaScript 靜態程式碼的語法和風格&lt;/strong&gt;，讓我們在編譯前可以減少錯誤產生，還能改善程式碼的品質與統一程式碼風格。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6-重點紀錄" scheme="https://visionyi.github.io/categories/ES6-%E9%87%8D%E9%BB%9E%E7%B4%80%E9%8C%84/"/>
    
    
      <category term="JavaScript" scheme="https://visionyi.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://visionyi.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 開發環境建置(上) - Babel 編譯工具</title>
    <link href="https://visionyi.github.io/2018/01/20/ES6-series14-build-dev-babel/"/>
    <id>https://visionyi.github.io/2018/01/20/ES6-series14-build-dev-babel/</id>
    <published>2018-01-19T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.024Z</updated>
    
    <content type="html"><![CDATA[<p>已經寫了好幾篇介紹 ES6 特色的文章，這次就來詳細介紹 JavaScript ES6 的開發環境要如何建立吧！由於文章內容有點長，就分為兩篇來討論，此篇主軸為 Babel，下一篇為 ESLint 的重點使用。</p><p>現今各大瀏覽器廠商所開發的 JavaScript 引擎還沒有對 ES6 標準中所有特性做到完美支持，不能直接放入，有些新語法會報錯。所以想使用這些新特性或語法在所有瀏覽器上，需要使用 <strong>Babel 編譯器</strong>來<strong>轉換成舊式的 ES5 標準代碼</strong>，才能完全符合環境的支持。</p><a id="more"></a><h2 id="建置開發目錄"><a href="#建置開發目錄" class="headerlink" title="建置開發目錄"></a>建置開發目錄</h2><h3 id="建立目錄"><a href="#建立目錄" class="headerlink" title="建立目錄"></a>建立目錄</h3><p>為了要簡單快速使用，我們建立以下目錄 :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">目錄</span><br><span class="line">|-- dist</span><br><span class="line">|-- src</span><br><span class="line">     |-- index.js</span><br><span class="line">|-- index.html</span><br></pre></td></tr></table></figure><ul><li>dist 資料夾 :<ul><li>此為 JS 檔案被 Babel 編譯成 ES5 代碼的資料夾，會讓 index.html 引入這裡的檔案</li></ul></li><li>src 資料夾 :<ul><li>預設為編寫 JS ES6 檔案的地方</li></ul></li><li>index.html 內容 :</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ES6 - Build Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello !!</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>src / index.js 內容 (簡單的 ES6 語法):</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getText = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'JavaScript ES6'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).innerHTML = getText();</span><br></pre></td></tr></table></figure><h3 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h3><p>在使用 Babel、ESLint 之前要先會用 <strong>npm 套件管理</strong>來安裝，這是在 Node.js 環境下執行的，不懂得可以先去 <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm 官網</a> 看看。</p><ul><li>在根目錄下指令 - 初始化 npm :</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm init</span><br></pre></td></tr></table></figure><ul><li>默認設定值就好，它在根目錄下會產生一個<code>package.json</code>檔案:</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"es6-buildtest"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>之後安裝的套件 Babel、ESLint 的所有工具都會在這個檔案中顯示出來，可以好方便管理</li></ul><h2 id="使用-Babel-編譯工具"><a href="#使用-Babel-編譯工具" class="headerlink" title="使用 Babel 編譯工具"></a>使用 Babel 編譯工具</h2><p><img src="https://i.imgur.com/afpxrCa.png" alt="Babel-logo"></p><p><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a> 是 JavaScript 的編譯器(compiler)工具，可以把 ES6 標準以上的新語法轉換成最基本的 JS 語法，另外也支援 react 語法轉換，只要簡單的配置就能完成，這已是現今非常流行的轉換工具了。Babel 搭配一些自動化打包套件還可以加快效率與自動運行，在前端工程中很受歡迎。</p><h3 id="工具說明"><a href="#工具說明" class="headerlink" title="工具說明"></a>工具說明</h3><h4 id="babelrc-配置檔案"><a href="#babelrc-配置檔案" class="headerlink" title=".babelrc 配置檔案"></a><code>.babelrc</code> 配置檔案</h4><ul><li>使用 Babel 的第一步就是建立此檔案，會存放在根目錄下</li><li>這是用來設置 Babel 的轉碼規則和插件</li><li>基本格式如下</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [],</span><br><span class="line">  <span class="attr">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="babel-preset-env-工具"><a href="#babel-preset-env-工具" class="headerlink" title="babel-preset-env 工具"></a><code>babel-preset-env</code> 工具</h4><ul><li>Babel 提供的轉碼規則包</li><li>這是包含最新的 es2015 ~ es2017 版的規則集內容，請參考 <a href="https://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="noopener">preset-env</a></li></ul><h4 id="babel-cli-工具"><a href="#babel-cli-工具" class="headerlink" title="babel-cli 工具"></a><code>babel-cli</code> 工具</h4><ul><li>Babel 提供的工具，可以執行指令行來進行轉碼</li><li>需要安裝在全域環境下才能使用 <code>babel</code> 命令</li><li>基本用法如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 轉碼後输出到畫面上</span><br><span class="line">babel example.js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 轉碼後寫入一個檔案中</span><br><span class="line">babel example.js -o compiled.js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 將整個目錄轉碼到輸出的目錄裡</span><br><span class="line">babel src -d dist</span><br></pre></td></tr></table></figure><ul><li>但全域環境下無法跟著本地專案的版本走，所以等等實際建置時會使用本地端安裝來進行</li></ul><h3 id="開始實際建置"><a href="#開始實際建置" class="headerlink" title="開始實際建置"></a>開始實際建置</h3><p><strong>1.</strong> 先在本地端安裝 <code>babel-cli</code>、<code>babel-preset-env</code> 工具 :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install babel-cli babel-preset-env --save-dev</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 這時候會在 package.json 檔案中看到多出<code>devDependencies</code>選項，代表安裝成功</p><blockquote><p>“devDependencies”: {<br>   “babel-cli”: “^6.26.0”,<br>   “babel-preset-env”: “^1.6.1”<br>}</p></blockquote><p><strong>3.</strong> 再來建立<code>.babelrc</code> Babel 的配置檔案，把轉碼規則包的套件填入，檔案內容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.</strong> 然後藉由 npm 的腳本自訂方式來代替 babel 命令，改寫 package.json 中<code>scripts</code>選項，內容如下</p><blockquote><p>“scripts”: {<br> “build”: “babel src -d dist”<br>}</p></blockquote><p><strong>5.</strong> 最後在終端機執行命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm run build</span><br></pre></td></tr></table></figure><p>可以看到運行的結果，dist 資料夾裡多了一個 index.js 檔如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getText = <span class="function"><span class="keyword">function</span> <span class="title">getText</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'JavaScript ES6'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).innerHTML = getText();</span><br></pre></td></tr></table></figure><p>這就代表編譯成 ES5 代碼成功啦！執行 index.html 在瀏覽器上看看是否會有預期的結果吧~</p><p>以上是 Babel 的基本使用，需要自己手動執行編譯的命令，由於很麻煩就有了第三方套件站出來了，自動化這些命令程序，接下來一節，我們使用另一個方法來讓它更方便。</p><h3 id="使用第三方套件-Gulp-運行-Babel-功能"><a href="#使用第三方套件-Gulp-運行-Babel-功能" class="headerlink" title="使用第三方套件 Gulp 運行 Babel 功能"></a>使用第三方套件 Gulp 運行 Babel 功能</h3><p><a href="https://gulpjs.com/" target="_blank" rel="noopener">Gulp</a> 是現今很流行的<strong>任務打包工具</strong>，主要用來自動化運行任務套件，像是編譯、最小化、合併…等等的任務。Gulp 的詳細教學就請先自行 google 吧，這裡將省略帶過。</p><h4 id="使用-Gulp-開始建置"><a href="#使用-Gulp-開始建置" class="headerlink" title="使用 Gulp 開始建置"></a>使用 Gulp 開始建置</h4><p><strong>1.</strong> 需要先安裝<code>gulp</code>與 Babel 提供的<code>gulp-babel</code>、<code>babel-core</code>、<code>babel-preset-env</code>這三套工具 :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install gulp gulp-babel babel-core babel-preset-env --save-dev</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 還是要建立 <code>.babelrc</code> 檔案 :</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> 然後建立 Gulp 需要運行的腳本檔案 <code>gulpfile.js</code>，放在根目錄下，<strong>內容為把 src 資料夾裡的檔案進行編譯後再放到 dist 資料夾中</strong>(可直接使用部分的 ES6 語法) :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'build'</span>, () =&gt;</span><br><span class="line">    gulp.src(<span class="string">'src/**'</span>)</span><br><span class="line">        .pipe(babel())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'dist'</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>4.</strong> 最後在終端機執行腳本命令，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gulp build</span><br></pre></td></tr></table></figure><p>對！ 你可以發現到，以上方法跟直接使用 <code>babel-cli</code> 命令行工具是一樣的效果。雖然它比較繁瑣，但別忘了 Gulp 的主要功能是<strong>自動化任務</strong>，繼續下面操作。</p><p><strong>5.</strong> 我們另外在 <code>gulpfile.js</code> 檔案中再加入<strong>自動化監看腳本</strong>的程式碼，如下 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'watch'</span>, () =&gt; &#123;</span><br><span class="line">    gulp.watch(<span class="string">'src/**'</span>, [<span class="string">'build'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>6.</strong> 使用監看腳本，終端機執行命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gulp watch</span><br></pre></td></tr></table></figure><p>當運行後，<strong>可以看到只要每次修改 src 資料夾裡的 JS 檔案，Gulp 將會自動執行 Babel 編譯動作</strong>，至少這樣就方便許多了。若搭配它的一些 API 還能與其他套件做結合呢！</p><p>下一篇文章<a href="/2018/01/21/ES6-series15-build-dev-eslint/">ES6 開發環境建置(下) - ESLint 偵錯工具</a> 將會介紹 ESLint 偵錯工具，可以在編譯前找出錯誤，規範好統一的程式碼風格。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已經寫了好幾篇介紹 ES6 特色的文章，這次就來詳細介紹 JavaScript ES6 的開發環境要如何建立吧！由於文章內容有點長，就分為兩篇來討論，此篇主軸為 Babel，下一篇為 ESLint 的重點使用。&lt;/p&gt;
&lt;p&gt;現今各大瀏覽器廠商所開發的 JavaScript 引擎還沒有對 ES6 標準中所有特性做到完美支持，不能直接放入，有些新語法會報錯。所以想使用這些新特性或語法在所有瀏覽器上，需要使用 &lt;strong&gt;Babel 編譯器&lt;/strong&gt;來&lt;strong&gt;轉換成舊式的 ES5 標準代碼&lt;/strong&gt;，才能完全符合環境的支持。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6-重點紀錄" scheme="https://visionyi.github.io/categories/ES6-%E9%87%8D%E9%BB%9E%E7%B4%80%E9%8C%84/"/>
    
    
      <category term="JavaScript" scheme="https://visionyi.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://visionyi.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 其他的 API 與特性擴展</title>
    <link href="https://visionyi.github.io/2018/01/13/ES6-series13-api-other-expansion/"/>
    <id>https://visionyi.github.io/2018/01/13/ES6-series13-api-other-expansion/</id>
    <published>2018-01-12T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.024Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript ES6 標準規範中，其實還有很多的新擴展、新語法、新 API 都很有特色，只是這些就比較不常用了，大部分的功能也都能使用舊方法去實現，至少這些新事物能幫助簡化程序就是一大進步了。</p><p>本篇將會簡單地介紹 ES6 其他較實用常見的 API 與擴展，主要知道基本內容就好，並不會深入探討。</p><a id="more"></a><h2 id="JavaScript-ES6-其他常見的新-API"><a href="#JavaScript-ES6-其他常見的新-API" class="headerlink" title="JavaScript ES6 其他常見的新 API"></a>JavaScript ES6 其他常見的新 API</h2><h3 id="Promise-物件"><a href="#Promise-物件" class="headerlink" title="Promise 物件"></a>Promise 物件</h3><ul><li>Promise 是一種非同步 (asynchronous) 處理的解決方案</li><li>特別參考<ul><li><a href="https://www.fooish.com/javascript/es6/Promise.html" target="_blank" rel="noopener">JavaScript ES6 Promise Object 物件</a></li><li><a href="https://wcc723.github.io/life/2017/05/25/promise/" target="_blank" rel="noopener">JavaScript ES6 Promise</a></li></ul></li><li>實用範例參考<ul><li><a href="https://eyesofkids.gitbooks.io/javascript-start-es6-promise/content/contents/snippets.html" target="_blank" rel="noopener">Promise 實例 &amp; 程式碼片段</a></li><li><a href="https://www.stephanboyer.com/post/107/fun-with-promises-in-javascript" target="_blank" rel="noopener">Fun with promises in JavaScript</a></li></ul></li></ul><h3 id="Set-物件"><a href="#Set-物件" class="headerlink" title="Set 物件"></a>Set 物件</h3><ul><li>這是新的資料結構物件，Set 類似於陣列，但內容成員不會有重複的值</li><li>放入有重複的值將會被覆蓋，內容成員總數不變</li><li>與 Map 物件一樣都有類似的操作方法與迭代方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用 add() 方法設置資料內容</span></span><br><span class="line">set.add(<span class="number">10</span>);</span><br><span class="line">set.add(<span class="number">10</span>);</span><br><span class="line">set.add(<span class="string">'text'</span>);</span><br><span class="line">set.add(&#123;<span class="attr">sayHi</span>: <span class="string">'Hi'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map);</span><br><span class="line"><span class="comment">// Set(4) &#123;10, "text", &#123;sayHi: "Hi"&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Proxy-物件"><a href="#Proxy-物件" class="headerlink" title="Proxy 物件"></a>Proxy 物件</h3><ul><li>概念為重新定義 JavaScript 中某些操作的原始行為，攔截那些操作方法去改變它</li><li>應用範例 :<ul><li>利用 Proxy 可以讓 “<strong>讀取 Object 的屬性值</strong>“ 轉變為 “<strong>執行某個函數</strong>“，從而實現屬性的方法操作，不需要建立函數</li><li>利用 Proxy 可以讓 “<strong>設定 Object 的屬性值</strong>“ 作為 “<strong>數據綁定</strong>“，發生變化時就會自動更新 DOM 與瀏覽器上的渲染</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 這是基本語法</span></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此用來攔截變數的 "物件內容"，改變它的原始行為</span></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, propKey, receiver</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'getting'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">target, propKey, value, receiver</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setting'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.test);  <span class="comment">// 'getting'</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.other); <span class="comment">// 'getting'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下都會執行 console.log('setting');</span></span><br><span class="line">proxy.abc = <span class="number">10</span>;</span><br><span class="line">proxy[<span class="number">10</span>] = <span class="string">'test'</span>;</span><br></pre></td></tr></table></figure><h3 id="Reflect-物件"><a href="#Reflect-物件" class="headerlink" title="Reflect 物件"></a>Reflect 物件</h3><ul><li>概念也是攔截 JavaScript 中某些操作方法去改變它</li><li>Reflect 可以在 Proxy 的內部方法調用，確保該操作方法會執行原始的行為，然後再執行 Proxy 內定義的額外的功能</li><li>另外 Reflect 物件的其他用途<ul><li>可以用來取代 Object 原型中部分的操作方法，改善了一些物件原始結構的問題</li></ul></li></ul><h3 id="Generator-生成器函數"><a href="#Generator-生成器函數" class="headerlink" title="Generator 生成器函數"></a>Generator 生成器函數</h3><ul><li>它有點類似一般的函數，使用關鍵詞<code>function*</code></li><li>Generator 的運作概念就像是一個狀態機 (state machine)，會一直改變內部的不同狀態</li><li>取得的 Generator 物件，起始狀態會先暫停什麼都不做，而每次執行<code>next()</code>方法，就會繼續執行函數，直到遇到下一個 yield 關鍵字，又會暫停函數的執行，而每一次暫停時會 yiled (產出)一個當前狀態值</li><li>yiled 會返回一個<code>{value: anyType, done: boolean}</code>結構的物件</li><li>Generator 產生的物件也有 Iterator 的性質，所以可以用<code>for...of</code>迭代迴圈去取得 yield 返回的 value 值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次執行 next() - 停在 yield 1</span></span><br><span class="line"><span class="comment">// 返回 Object &#123;value: 1, done: false&#125;</span></span><br><span class="line">g.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次執行 next() - 停在 yield 2</span></span><br><span class="line"><span class="comment">// 返回 Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">g.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次執行 next() - 沒有 yield 將會結束</span></span><br><span class="line"><span class="comment">// 返回 Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line">g.next();</span><br></pre></td></tr></table></figure><h2 id="JavaScript-ES6-其他較實用的擴展"><a href="#JavaScript-ES6-其他較實用的擴展" class="headerlink" title="JavaScript ES6 其他較實用的擴展"></a>JavaScript ES6 其他較實用的擴展</h2><ul><li>字串 (Sting) 可使用 <strong>Unicode 表示法</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unicode 表示法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"</span>); <span class="comment">// ABC</span></span><br></pre></td></tr></table></figure><ul><li>數值 (Number) 可以使用<strong>二進制和八進製表示法</strong><ul><li>前綴須加上<code>0b</code>(或<code>0B</code>)、<code>0o</code>(或<code>0O</code>)表示</li></ul></li><li>數值 (Number) 可以使用<code>**</code>關鍵字當作<strong>指數運算</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二進制和八進製表示法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0b1100011</span>); <span class="comment">// 99</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0o143</span>); <span class="comment">// 99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指數運算</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>**<span class="number">6</span>); <span class="comment">// 64</span></span><br></pre></td></tr></table></figure><h2 id="JavaScript-ES6-其他新功能-參考網址"><a href="#JavaScript-ES6-其他新功能-參考網址" class="headerlink" title="JavaScript ES6 其他新功能 - 參考網址"></a>JavaScript ES6 其他新功能 - 參考網址</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_2015_support_in_Mozilla" target="_blank" rel="noopener">ECMAScript 2015 support in Mozilla</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JavaScript ES6 標準規範中，其實還有很多的新擴展、新語法、新 API 都很有特色，只是這些就比較不常用了，大部分的功能也都能使用舊方法去實現，至少這些新事物能幫助簡化程序就是一大進步了。&lt;/p&gt;
&lt;p&gt;本篇將會簡單地介紹 ES6 其他較實用常見的 API 與擴展，主要知道基本內容就好，並不會深入探討。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6-重點紀錄" scheme="https://visionyi.github.io/categories/ES6-%E9%87%8D%E9%BB%9E%E7%B4%80%E9%8C%84/"/>
    
    
      <category term="JavaScript" scheme="https://visionyi.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://visionyi.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Module System 模組系統</title>
    <link href="https://visionyi.github.io/2018/01/12/ES6-series12-module-system/"/>
    <id>https://visionyi.github.io/2018/01/12/ES6-series12-module-system/</id>
    <published>2018-01-11T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.024Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 導入了模組系統的支援，它採用了 CommonJS 與 AMD 的優點，<strong>在編譯時進行靜態加載，而且可以使用於瀏覽器與伺服器端</strong>。概念上是將一個大程序拆分成互相依賴的小文件，需要用到時就拼裝起來使用，這對開發大型或複雜的專案是很重要的。</p><a id="more"></a><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>ES6 的模組程式碼會自動採用嚴格模式，不管是否有使用<code>&quot;use strict&quot;</code></li><li>ES6 的模組是一個檔案一個模組</li><li>主要使用兩個語句構成 :<ul><li><strong><code>export</code>做為模組對外的輸出</strong>，放於檔案最後</li><li><strong><code>import</code>做為輸入其他模組的功能</strong>，放於檔案開頭</li></ul></li></ul><h2 id="基本的輸出與輸入"><a href="#基本的輸出與輸入" class="headerlink" title="基本的輸出與輸入"></a>基本的輸出與輸入</h2><ul><li>物件、類別、函數、常數…等等有變數名稱的都可以輸出</li><li>都可以使用<code>as</code>關鍵字<strong>重新命名變數名稱</strong></li></ul><h3 id="export-輸出方式"><a href="#export-輸出方式" class="headerlink" title="export 輸出方式"></a>export 輸出方式</h3><ol><li>在定義時直接做為輸出</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> str = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'function test'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用已定義好或已存在的變數做為輸出，須加上大括號<code>{}</code>，用來<strong>統一輸出</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用大括號"&#123;&#125;"做統一輸出</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'function test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也能使用 as 重新命名</span></span><br><span class="line"><span class="keyword">export</span> &#123;str, obj, foo <span class="keyword">as</span> fooTest&#125;;</span><br></pre></td></tr></table></figure><h3 id="import-輸入方式"><a href="#import-輸入方式" class="headerlink" title="import 輸入方式"></a>import 輸入方式</h3><ol><li>使用<strong>大括號</strong><code>{}</code>輸入模組中有被 export 過的變數，後面加上檔案路徑或模組名稱</li><li>使用<strong>萬用字元</strong><code>*</code>輸入模組中所有被 export 過的變數</li><li>直接加載整個模組名稱，只用來執行模組而已</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本使用，假設輸出模組的檔案名稱為 myModule.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;str, obj, fooTest&#125; <span class="keyword">from</span> <span class="string">'./myModule.js'</span>;</span><br><span class="line"></span><br><span class="line">fooTest();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用萬用字元*</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="built_in">module</span> <span class="keyword">from</span> <span class="string">'./myModule.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.str);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接加載整個模組名稱</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'jquery'</span>;</span><br></pre></td></tr></table></figure><h2 id="使用-export-default-輸出與輸入"><a href="#使用-export-default-輸出與輸入" class="headerlink" title="使用 export default 輸出與輸入"></a>使用 <code>export default</code> 輸出與輸入</h2><ul><li>主要是用來當作模組檔案<strong>唯一的接口</strong>，指定為模組的”<strong>默認輸出</strong>“</li><li>可以輸出<strong>匿名型態的函數、類別</strong></li><li>輸入時可以<strong>指定任意名稱</strong>做為輸入的變數</li><li>輸入與輸出都不必再加上大括號<code>{}</code>了</li><li>一個模組只能有一個默認輸出</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 檔名: export.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">circleArea</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'area: '</span>, r * r * <span class="number">3.14</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> circleArea;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 檔名: import.js</span></span><br><span class="line"><span class="keyword">import</span> getArea <span class="keyword">from</span> <span class="string">'./export.js'</span>;</span><br><span class="line"></span><br><span class="line">getArea(<span class="number">10</span>); <span class="comment">// area: 100</span></span><br></pre></td></tr></table></figure><h2 id="export-與-import-的複合寫法"><a href="#export-與-import-的複合寫法" class="headerlink" title="export 與 import 的複合寫法"></a>export 與 import 的複合寫法</h2><p>概念為<strong>可以先輸入後輸出同一個模組</strong>，export 和 import 語句結合在一起的意思。主要用來<strong>把接口輸出改名</strong>或<strong>改成默認的接口輸出</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; obj, foo &#125; <span class="keyword">from</span> <span class="string">'./myModule.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同於</span></span><br><span class="line"><span class="keyword">import</span> &#123; obj, foo &#125; <span class="keyword">from</span> <span class="string">'./myModule.js'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; obj, foo &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改成默認的接口輸出</span></span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./lib.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同於</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'./lib.js'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br></pre></td></tr></table></figure><h2 id="如何在瀏覽器中運行實現"><a href="#如何在瀏覽器中運行實現" class="headerlink" title="如何在瀏覽器中運行實現"></a>如何在瀏覽器中運行實現</h2><p>基本上 ES6 的程式碼使用 Babel 轉譯成舊式的 JS 語法已經習以為常，但現今已有許多瀏覽器都支援 ES6 與模組系統了，可以直接寫入語法，支援的瀏覽器參考 <a href="https://caniuse.com/#search=module" target="_blank" rel="noopener">Can I use …</a></p><p>運行模組系統使用以下方式 :</p><ul><li>使用<code>&lt;script&gt;</code>標籤，再加入<code>type=&quot;module&quot;</code>屬性，直接放入 HTML 檔案上就行了</li><li><strong>只需要寫入主要執行的 JS 檔案</strong>，其他組件或外部檔案可以不必寫入，<strong>模組系統會自動去關聯其他被 import 的 JS 檔案</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 檔名: main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="built_in">module</span> <span class="keyword">from</span> <span class="string">'./myModule.js'</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 檔名: index.html</span></span><br><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"./main.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>瀏覽器也允許內嵌語法在 HTML 網頁中</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> <span class="built_in">module</span> <span class="keyword">from</span> <span class="string">'./myModule.js'</span>;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>註 : 有些瀏覽器需要藉由伺服器去運行，直接開啟 HTML 檔案是不行的</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 導入了模組系統的支援，它採用了 CommonJS 與 AMD 的優點，&lt;strong&gt;在編譯時進行靜態加載，而且可以使用於瀏覽器與伺服器端&lt;/strong&gt;。概念上是將一個大程序拆分成互相依賴的小文件，需要用到時就拼裝起來使用，這對開發大型或複雜的專案是很重要的。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6-重點紀錄" scheme="https://visionyi.github.io/categories/ES6-%E9%87%8D%E9%BB%9E%E7%B4%80%E9%8C%84/"/>
    
    
      <category term="JavaScript" scheme="https://visionyi.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://visionyi.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Map 物件</title>
    <link href="https://visionyi.github.io/2018/01/11/ES6-series11-map/"/>
    <id>https://visionyi.github.io/2018/01/11/ES6-series11-map/</id>
    <published>2018-01-10T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.023Z</updated>
    
    <content type="html"><![CDATA[<p>這是 ES6 中一種新的資料結構，<strong>每組資料都有對應的 key 值與 value 值</strong>，所以 Map 在意義上類似於物件。</p><p>而 key 值的範圍不限於字串，可以是各種類型的值（包括 number、array、object、function、symbol…等等）都可以當作 key，是一種更完善的 Hash 結構實現。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map 基本使用</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用 set() 方法設置資料內容</span></span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="number">1</span>);</span><br><span class="line">map.set(<span class="number">10</span>, <span class="string">'ten'</span>);</span><br><span class="line">map.set(&#123;<span class="attr">sayHi</span>: <span class="string">'Hi'</span>&#125;, <span class="string">'obj'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map);</span><br><span class="line"><span class="comment">// Map(3) &#123;"first" =&gt; 1, 10 =&gt; "ten", &#123;…&#125; =&gt; "obj"&#125;</span></span><br></pre></td></tr></table></figure><h2 id="內部為-key-value-的資料結構"><a href="#內部為-key-value-的資料結構" class="headerlink" title="內部為 [key, value] 的資料結構"></a>內部為 <code>[key, value]</code> 的資料結構</h2><ul><li>使用<code>new</code>產生 Map 物件</li><li>在產生 Map 時也可以接收以下的參數<ol><li>有著<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" rel="noopener">迭代協議</a>的物件結構</li><li>陣列集合，類似 – <code>[[&#39;key1&#39;, &#39;value1&#39;], [&#39;key2&#39;, &#39;value2&#39;]]</code></li></ol></li><li>搭配<code>for..of</code>迭代循環可單獨取得所有的<code>[key, value]</code></li><li>可以使用<code>...</code>擴展運算子取得陣列集合</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放置陣列集合</span></span><br><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">'first'</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">10</span>, <span class="string">'ten'</span>],</span><br><span class="line">    [&#123;<span class="attr">sayHi</span>: <span class="string">'Hi'</span>&#125;, <span class="string">'obj'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搭配 for...of 循環取得[key, value]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map2) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搭配擴展運算子取得陣列集合</span></span><br><span class="line"><span class="built_in">console</span>.log([...map1]);</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log([...map2]);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    ['first', 1],</span></span><br><span class="line"><span class="comment">//    [10, 'ten'],</span></span><br><span class="line"><span class="comment">//    [&#123;sayHi: 'Hi'&#125;, 'obj']</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><h2 id="Map-的操作方法"><a href="#Map-的操作方法" class="headerlink" title="Map 的操作方法"></a>Map 的操作方法</h2><ul><li><code>set(key, value)</code>: 設置內容</li><li><code>get(key)</code>: 獲取指定 key 的內容，若找不到返回<code>undefined</code></li><li><code>has(key)</code>: 檢查是否存在此 key，有則返回<code>ture</code>，無則返回<code>false</code></li><li><code>delete(key)</code>: 刪除指定 key 的內容，成功返回<code>ture</code>，失敗返回<code>false</code></li><li><code>clear()</code>: 刪除所有內容成員</li><li><code>size 屬性</code>: 取得內容成員總數</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="number">1</span>);</span><br><span class="line">map.set(<span class="number">10</span>, <span class="string">'ten'</span>);</span><br><span class="line">map.set(&#123;<span class="attr">sayHi</span>: <span class="string">'Hi'</span>&#125;, <span class="string">'obj'</span>);</span><br><span class="line">map.set(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'key'</span>, <span class="number">123</span>);</span><br><span class="line">map.set(<span class="built_in">Symbol</span>(<span class="string">'items'</span>), [<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">map.get(<span class="number">10</span>)    <span class="comment">// 'ten'</span></span><br><span class="line">map.has(<span class="string">'first'</span>)    <span class="comment">// 'ture'</span></span><br><span class="line"></span><br><span class="line">map.delete(<span class="string">'first'</span>)</span><br><span class="line">map.get(<span class="string">'first'</span>)    <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">map.size    <span class="comment">// 4</span></span><br><span class="line">map.clear()</span><br><span class="line">map.size    <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h2 id="Map-的迭代方法"><a href="#Map-的迭代方法" class="headerlink" title="Map 的迭代方法"></a>Map 的迭代方法</h2><p>這些方法函數所產生的內容都是 “<strong>迭代器(iterator)的資料類型</strong>“，可以使用<code>for...of</code>迴圈取得個別單獨的值，也能使用<code>...</code>擴展運算符直接轉成陣列類型。</p><ul><li><code>keys()</code>: 取得所有 key</li><li><code>values()</code>: 取得所有成員的值</li><li><code>entries()</code>: 取得所有內容成員</li><li><code>forEach()</code>: 走訪 Map 的所有成員</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="string">'two'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'one'</span></span><br><span class="line"><span class="comment">// 'two'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 'one'</span></span><br><span class="line"><span class="comment">// 2 'two'</span></span><br><span class="line"><span class="comment">// 等同於</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也能使用...擴展運算子直接轉成陣列類型</span></span><br><span class="line"><span class="built_in">console</span>.log([...map.keys()]);  <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log([...map.values()]);  <span class="comment">// ['one', 'two']</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這是 ES6 中一種新的資料結構，&lt;strong&gt;每組資料都有對應的 key 值與 value 值&lt;/strong&gt;，所以 Map 在意義上類似於物件。&lt;/p&gt;
&lt;p&gt;而 key 值的範圍不限於字串，可以是各種類型的值（包括 number、array、object、function、symbol…等等）都可以當作 key，是一種更完善的 Hash 結構實現。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6-重點紀錄" scheme="https://visionyi.github.io/categories/ES6-%E9%87%8D%E9%BB%9E%E7%B4%80%E9%8C%84/"/>
    
    
      <category term="JavaScript" scheme="https://visionyi.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://visionyi.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Symbol 資料類型</title>
    <link href="https://visionyi.github.io/2018/01/10/ES6-series10-symbol/"/>
    <id>https://visionyi.github.io/2018/01/10/ES6-series10-symbol/</id>
    <published>2018-01-09T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.023Z</updated>
    
    <content type="html"><![CDATA[<p>這是 ES6 中一種新的原始資料類型，表示<strong>獨一無二的值</strong>，Symbol 的值通過<code>Symbol</code>函數生成，可以<strong>保證不會與其他屬性名或數值產生衝突</strong>，所以很適合用來代替傳統<strong>定義常數內容值的方式</strong>。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s  <span class="comment">// "symbol"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定義常數內容值</span></span><br><span class="line"><span class="keyword">const</span> ERROR = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> NOTICE = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> WARNING = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> CRITICAL = <span class="built_in">Symbol</span>();</span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li>Symbol 函數可以接受一個字串作為參數</li><li>Symbol 值不能與其他類型的值進行運算</li><li>Symbol 值可轉成完全字串，使用<code>toString()</code>方法，若有參數也會一同輸出</li><li>Symbol 值可作為物件中的屬性名，使用中括號<code>[]</code>，<strong>能防止此屬性名(關鍵字)被改寫或覆蓋</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 獨一無二不會有任何相同的值，儘管接受的參數是相同的</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'new'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'new'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可轉成完全字串</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.toString()); <span class="comment">// 'Symbol(new)'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可作為物件中的屬性名</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [s1]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; Symbol(new): "Hello!" &#125;</span></span><br></pre></td></tr></table></figure><h2 id="進階使用"><a href="#進階使用" class="headerlink" title="進階使用"></a>進階使用</h2><p>Symbol 作為屬性名時，該屬性不會出現在<code>for...in</code>、<code>for...of</code>迴圈迭代中，也不會在<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>等等之類的方法中被獲取，<strong>只有唯一使用<code>Object.getOwnPropertySymbols()</code> 此方法才能獲取擁有 Symbol 值的屬性名</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'s1'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'s2'</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [s1]: <span class="string">'Hello'</span>,</span><br><span class="line">    [s2]: <span class="string">'World'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// 無輸出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> propertyNames = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line"><span class="built_in">console</span>.log(propertyNames); <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> propertySymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"><span class="built_in">console</span>.log(propertySymbols); <span class="comment">// [ Symbol(s1), Symbol(s2) ]</span></span><br></pre></td></tr></table></figure><h3 id="應用"><a href="#應用" class="headerlink" title="應用:"></a>應用:</h3><ul><li>Symbol 屬性不會被常規方法獲取，適合用在定義物件類別(class)中的非私有的、但又希望只用於內部的方法</li></ul><h2 id="Symbol-for-amp-Symbol-keyFor"><a href="#Symbol-for-amp-Symbol-keyFor" class="headerlink" title="Symbol.for() &amp; Symbol.keyFor()"></a>Symbol.for() &amp; Symbol.keyFor()</h2><ul><li><code>Symbol.for()</code>: 可以重新使用同一個 Symbol 值，若定義時輸入參數一樣，則 Symbol 值會相等</li><li><code>Symbol.keyFor()</code>: 可以取得在使用<code>Symbol.for()</code>定義時所輸入的參數值</li><li>使用此 2 個函數方法來重複利用資源</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'new'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'new'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// 'new'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由於 Symbol() 是沒有登記機制的，所以使用 .keyFor() 會無效</span></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>(<span class="string">'new'</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s3) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h3><p>作為 ES6 iterator(迭代器)的建構方法名稱，可參考: <a href="https://ponyfoo.com/articles/es6-iterators-in-depth" target="_blank" rel="noopener">ES6 Iterators in Depth</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這是 ES6 中一種新的原始資料類型，表示&lt;strong&gt;獨一無二的值&lt;/strong&gt;，Symbol 的值通過&lt;code&gt;Symbol&lt;/code&gt;函數生成，可以&lt;strong&gt;保證不會與其他屬性名或數值產生衝突&lt;/strong&gt;，所以很適合用來代替傳統&lt;strong&gt;定義常數內容值的方式&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6-重點紀錄" scheme="https://visionyi.github.io/categories/ES6-%E9%87%8D%E9%BB%9E%E7%B4%80%E9%8C%84/"/>
    
    
      <category term="JavaScript" scheme="https://visionyi.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://visionyi.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 class 類別語法</title>
    <link href="https://visionyi.github.io/2018/01/07/ES6-series9-class/"/>
    <id>https://visionyi.github.io/2018/01/07/ES6-series9-class/</id>
    <published>2018-01-06T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.026Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 中的<code>class</code>類別，它是效仿其他程式語言擁有物件導向(OOP)的概念，取代需要原型 prototype 的操作，因為寫法更簡潔與易於理解，用來代替 javascript 傳統建構物件的形式。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class 的建構子</span></span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// class 的方法</span></span><br><span class="line">    getPoint() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> foo <span class="comment">// "function"</span></span><br><span class="line">foo === foo.prototype.constructor <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> foo(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f.getPoint()); <span class="comment">// &#123;x: 10, y: 20&#125;</span></span><br></pre></td></tr></table></figure><h2 id="使用特性"><a href="#使用特性" class="headerlink" title="使用特性"></a>使用特性</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li><code>class</code> 本身原型是指向建構函數 function</li><li>本身 <code>prototype</code> 的屬性還是存在的</li><li>內部有個默認的 <code>constructor</code> 建構子函數</li><li><code>class</code> 本身也可以使用表達式的來定義</li></ul><h3 id="進階使用"><a href="#進階使用" class="headerlink" title="進階使用"></a>進階使用</h3><ul><li>可以使用<strong>靜態方法</strong>，在定義方法的前面加上 <code>static</code> 關鍵字</li><li>可以通過 <code>extends</code> 關鍵字進行<strong>物件繼承</strong></li><li>繼承後要調用父類的方法或屬性使用 <code>super</code> 關鍵字</li><li>缺陷: 目前沒有 “私有(private)/公開(publice)” 方法與屬性的關鍵字，但可以使用新的資料型態 <code>Symbol</code> 唯一性的形式定義</li></ul><h3 id="細節用法"><a href="#細節用法" class="headerlink" title="細節用法"></a>細節用法</h3><p>可以參考: <a href="https://www.fooish.com/javascript/es6/class.html" target="_blank" rel="noopener">ES6 class 關鍵字</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 中的&lt;code&gt;class&lt;/code&gt;類別，它是效仿其他程式語言擁有物件導向(OOP)的概念，取代需要原型 prototype 的操作，因為寫法更簡潔與易於理解，用來代替 javascript 傳統建構物件的形式。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6-重點紀錄" scheme="https://visionyi.github.io/categories/ES6-%E9%87%8D%E9%BB%9E%E7%B4%80%E9%8C%84/"/>
    
    
      <category term="JavaScript" scheme="https://visionyi.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://visionyi.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 物件語法糖的擴展</title>
    <link href="https://visionyi.github.io/2018/01/06/ES6-series8-object-syntax-sugar-expansion/"/>
    <id>https://visionyi.github.io/2018/01/06/ES6-series8-object-syntax-sugar-expansion/</id>
    <published>2018-01-05T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.025Z</updated>
    
    <content type="html"><![CDATA[<p>物件在 JavaScript 中是非常重要的資料結構，而在 ES6 之後擴展了它的語法結構，讓表示法變得更簡單易懂，還增加了屬性名稱的動態改變。</p><a id="more"></a><ul><li>擁有更簡潔的表示法<ul><li>允許直接寫入變數和函數，作為物件的屬性和方法</li><li>應用 :<ul><li>用於簡化函數的<strong>返回值或輸入參數</strong></li><li>使用於<strong>物件的解構賦值</strong></li></ul></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 對物件直接寫入變數和函數，省略了許多關鍵詞</span></span><br><span class="line"><span class="keyword">let</span> birth = <span class="string">'2018/01/01'</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">'老王'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等同於 birth: birth</span></span><br><span class="line">    birth,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等同於 sayHello: function() &#123;...&#125;</span></span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'My name is '</span>+ <span class="keyword">this</span>.name + <span class="string">' '</span> + <span class="keyword">this</span>.birth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayHello();  <span class="comment">// 'My name is 老王 2018/01/01'</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 簡化函數的物件返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPoint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getPoint()); <span class="comment">// &#123; x: 5, y: 10 &#125;</span></span><br></pre></td></tr></table></figure><ul><li>允許在定義物件時，屬性名稱是可變化的，需用<code>[]</code>包覆，但<strong>內容還是只能使用字串</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義物件時，屬性名稱是可變化的</span></span><br><span class="line"><span class="keyword">let</span> key = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [key]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);  <span class="comment">// &#123; Hello: true, abc: 123 &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;物件在 JavaScript 中是非常重要的資料結構，而在 ES6 之後擴展了它的語法結構，讓表示法變得更簡單易懂，還增加了屬性名稱的動態改變。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6-重點紀錄" scheme="https://visionyi.github.io/categories/ES6-%E9%87%8D%E9%BB%9E%E7%B4%80%E9%8C%84/"/>
    
    
      <category term="JavaScript" scheme="https://visionyi.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://visionyi.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 箭頭函數 Arrow Function</title>
    <link href="https://visionyi.github.io/2018/01/05/ES6-series7-arrow-function/"/>
    <id>https://visionyi.github.io/2018/01/05/ES6-series7-arrow-function/</id>
    <published>2018-01-04T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.025Z</updated>
    
    <content type="html"><![CDATA[<p>它是 ES6 標準裡其中非常受歡迎的新語法，允許使用 <code>=&gt;</code>(箭頭) 來定義函數，比起一般函數可以用更簡短的語法來表示，可以讓程式碼的可閱讀性提高。</p><a id="more"></a><ul><li>基本語法為 <code>函數的參數 =&gt; 返回值的內容</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般函數寫法，輸入半徑求圓面積</span></span><br><span class="line"><span class="keyword">let</span> circleArea = <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r * r * <span class="number">3.14</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭頭函數寫法</span></span><br><span class="line"><span class="keyword">let</span> circleArea = <span class="function"><span class="params">r</span> =&gt;</span> r * r * <span class="number">3.14</span>;</span><br><span class="line">circleArea(<span class="number">10</span>); <span class="comment">// 314</span></span><br></pre></td></tr></table></figure><h2 id="使用特性"><a href="#使用特性" class="headerlink" title="使用特性"></a>使用特性</h2><ul><li>擁有<strong>匿名函數</strong> (anonymous function) 的特性</li><li>若<strong>無參數</strong>或有<strong>多個參數</strong>，需要在參數部分加上括號<code>()</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 無參數</span></span><br><span class="line"><span class="keyword">let</span> greeting = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'Hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多個參數</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> n1 + n2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting());  <span class="comment">// 'Hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><ul><li>若返回值或參數有包含<code>{}</code>，像是<strong>物件內容</strong>，需要在外圍加上括號<code>()</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> foo2 = <span class="function">(<span class="params">&#123;x, y&#125;</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo()); <span class="comment">// &#123;x: 10, y: 20&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo2(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>若箭頭後面的程式區塊是<strong>陳述式</strong>或<strong>多條語句</strong>，需要加上大括號<code>{}</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getDate = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> date.toISOString().substr(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getDate()); <span class="comment">// 2018-01-03</span></span><br></pre></td></tr></table></figure><ul><li>非常適合簡化回調函數 (callback function)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.map(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [10, 20, 30]</span></span><br></pre></td></tr></table></figure><ul><li>箭頭函數也跟一般函數一樣，參數可以有<strong>預設值、解構賦值、rest 參數</strong>的功能</li><li>另外箭頭函數中沒有 <code>arguments</code> 物件，需要使用 rest 參數代替</li></ul><h2 id="綁定-this"><a href="#綁定-this" class="headerlink" title="綁定 this"></a>綁定 this</h2><ul><li>原本一般函數裡的 this 物件的指向是可變的，會隨著外層運作的函數而改變</li><li>但是在箭頭函數中，<strong>它會變成固定的</strong>，this 會被綁定在當時”<strong>所定義的作用域中</strong>“，而不會隨著環境改變成指向”<strong>運作時的作用域中</strong>“</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 addEventListener 監聽事件</span></span><br><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span><br><span class="line"><span class="keyword">var</span> fn_arrow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 建立 function 時 this 指向 Window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.constructor.name);  <span class="comment">// 執行 function 時 this 指向 Window</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 建立 function 時 this 指向 Window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.constructor.name);  <span class="comment">// 執行 function 時 this 指向 HTMLButtonElement</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, fn_arrow);</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, fn);</span><br></pre></td></tr></table></figure><blockquote><p>上面程式範例參考來自: <a href="https://pjchender.blogspot.tw/2017/01/es6-arrow-function.html" target="_blank" rel="noopener">https://pjchender.blogspot.tw/2017/01/es6-arrow-function.html</a></p></blockquote><ul><li>下面另一個例子，箭頭函數會綁定外層定義的 this 物件，而一般函數則會指向正在運作自己的函數</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.s1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.s2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箭頭函數，會綁定外層定義的 this</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.s1++, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般函數，指向正在運作自己的函數</span></span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s2++;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 過 0.3 秒後觀察 timer.s1 與 timer.s2 的變化</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'s1: '</span>, timer.s1), <span class="number">350</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'s2: '</span>, timer.s2), <span class="number">350</span>);</span><br><span class="line"><span class="comment">// s1: 3</span></span><br><span class="line"><span class="comment">// s2: 0</span></span><br></pre></td></tr></table></figure><ul><li>由於箭頭函數的 this 已經被綁定住了，所以不能使用函數的 <code>call()</code>、<code>apply()</code>、<code>bind()</code> 這些方法去改變 this 的指向</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> people = &#123;</span><br><span class="line">    name: <span class="string">'Bob'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn_arrow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn_arrow.call(people); <span class="comment">// 箭頭函數，this 依然還是 window 物件</span></span><br><span class="line">fn.call(people);  <span class="comment">// 一般函數，this 則改變成 people 物件</span></span><br></pre></td></tr></table></figure><h3 id="好處"><a href="#好處" class="headerlink" title="好處"></a>好處</h3><ul><li>編寫內層函數想取用外層的 this 物件時，可以省略 <code>var self = this</code> 此步驟而直接使用了</li><li>解決了在建立內層函數或填入回調函數時的，裡面的 this 可能會指向全域物件 window 的問題</li></ul><h2 id="不可使用箭頭函數的情況"><a href="#不可使用箭頭函數的情況" class="headerlink" title="不可使用箭頭函數的情況"></a>不可使用箭頭函數的情況</h2><ol><li><p>DOM 在處理監聽事件<code>addEventListener()</code>時，<strong>放入的回調函數</strong>盡量不要使用箭頭函數</p><ul><li>因為 this 不會隨著監聽事件所操作的 DOM 物件而改變</li></ul></li><li><p>定義物件屬性中的<strong>方法</strong>，或者定義建構函數的 <strong><code>prototype</code>方法</strong>，不能使用箭頭函數來定義</p><ul><li>因為 this 不會指向物件或建構函數本身，而是全域物件 window 或是外層的作用域(函數)</li></ul></li><li><p><strong>定義建構函數</strong>，一樣不能使用箭頭函數來定義</p><ul><li>因為在定義完後，只要使用<code>new</code>產生此建構的物件就會報錯</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;它是 ES6 標準裡其中非常受歡迎的新語法，允許使用 &lt;code&gt;=&amp;gt;&lt;/code&gt;(箭頭) 來定義函數，比起一般函數可以用更簡短的語法來表示，可以讓程式碼的可閱讀性提高。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6-重點紀錄" scheme="https://visionyi.github.io/categories/ES6-%E9%87%8D%E9%BB%9E%E7%B4%80%E9%8C%84/"/>
    
    
      <category term="JavaScript" scheme="https://visionyi.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://visionyi.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 函數中的預設參數 &amp; Rest 參數</title>
    <link href="https://visionyi.github.io/2018/01/04/ES6-series6-func-default-parameters-rest/"/>
    <id>https://visionyi.github.io/2018/01/04/ES6-series6-func-default-parameters-rest/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.025Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 終於讓函數也能有預設值了，在 ES6 中為函數加入了預設參數 (Default parameters) 與 Rest 參數的語法，在設計或建構時能更直覺的加入參數值了。</p><a id="more"></a><h2 id="函數中的預設參數"><a href="#函數中的預設參數" class="headerlink" title="函數中的預設參數"></a>函數中的預設參數</h2><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h3><p>預設參數是為了代替傳統的方式，解決了需要判斷是否為<code>undefined</code>才能設置預設值的麻煩</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函數中的預設參數</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(a * b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同於</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    b = (<span class="keyword">typeof</span> b !== <span class="string">'undefined'</span>) ?  b : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(a * b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiply(<span class="number">10</span>, <span class="number">2</span>); <span class="comment">// 20</span></span><br><span class="line">multiply(<span class="number">10</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h3 id="使用特性"><a href="#使用特性" class="headerlink" title="使用特性"></a>使用特性</h3><ul><li>預設參數可以是任何表達式，甚至可以取前一個變數來使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultParam</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="string">'test'</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b = a * <span class="number">2</span>, c = defaultParam(</span>)) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>); <span class="comment">// 10 20 'test'</span></span><br></pre></td></tr></table></figure><ul><li>預設參數可以與解構賦值結合使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函數參數的預設值設為空物件，也設置了解構賦值的預設值</span></span><br><span class="line"><span class="comment">// 此方式是為了避免產生 undefined</span></span><br><span class="line"><span class="comment">// 只要不是傳入物件，對應錯誤就會觸發參數預設值，再進而觸發解構賦值的內容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log([x, y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();    <span class="comment">// [0, 0]</span></span><br><span class="line">foo(&#123;&#125;);  <span class="comment">// [0, 0]</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span>&#125;);  <span class="comment">// [10, 20]</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">5</span>&#125;);    <span class="comment">// [5, 0]</span></span><br><span class="line">foo(&#123;<span class="attr">z</span>: <span class="number">1</span>&#125;);    <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><ul><li>如果傳入<code>undefined</code>將會觸發參數等於預設值，但傳入<code>null</code>則沒有這個效果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放入 undefined 與 null 的差別</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span>, y = <span class="number">10</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="literal">undefined</span>, <span class="literal">null</span>); <span class="comment">// 5 null</span></span><br></pre></td></tr></table></figure><h2 id="Rest-參數"><a href="#Rest-參數" class="headerlink" title="Rest 參數"></a>Rest 參數</h2><h3 id="主要用途-1"><a href="#主要用途-1" class="headerlink" title="主要用途"></a>主要用途</h3><ul><li>Rest 參數是取得剩下的參數後存放在同一個陣列裡</li><li>由三個點組成<code>...</code>，後面再加上<strong>陣列變數名稱</strong>，與擴展運算子很相似，但兩者是相反的概念</li><li>主要是代替函數中的<code>arguments</code>物件，其實不能說完全取代，因為<code>arguments</code>內還有其他參數，但常用來獲取裡面的陣列，只是繁瑣的轉換過程比較麻煩</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函數中的 Rest 參數</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同於</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// []</span></span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>); <span class="comment">// [10, 20, 30]</span></span><br></pre></td></tr></table></figure><h3 id="使用特性-1"><a href="#使用特性-1" class="headerlink" title="使用特性"></a>使用特性</h3><ul><li>rest 參數必須是最後一個參數，否則會產生錯誤</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, ...b, c</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// SyntaxError: Rest parameter must be last formal parameter</span></span><br></pre></td></tr></table></figure><ul><li>主要是放在函數中使用，但也能拿來做<strong>解構賦值</strong></li><li>在進行解構賦值時，等號左邊可以使用 rest 參數，右邊使用為 spread 擴展運算子</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用在解構賦值上</span></span><br><span class="line"><span class="comment">// 將兩個陣列合併後再做排序大小，最後取出第一個值</span></span><br><span class="line"><span class="keyword">let</span> spread1 = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> spread2 = [<span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, ...rest] = [...spread1, ...spread2].sort();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// [2, 3, 5, 6, 8]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 終於讓函數也能有預設值了，在 ES6 中為函數加入了預設參數 (Default parameters) 與 Rest 參數的語法，在設計或建構時能更直覺的加入參數值了。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6-重點紀錄" scheme="https://visionyi.github.io/categories/ES6-%E9%87%8D%E9%BB%9E%E7%B4%80%E9%8C%84/"/>
    
    
      <category term="JavaScript" scheme="https://visionyi.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://visionyi.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 擴展運算子 Spread Operator</title>
    <link href="https://visionyi.github.io/2018/01/02/ES6-series5-spread-operator/"/>
    <id>https://visionyi.github.io/2018/01/02/ES6-series5-spread-operator/</id>
    <published>2018-01-01T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.025Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 加入了新的運算子<code>...</code> Spread Operator，簡化了展開<strong>陣列</strong>的過程，應用上真的非常廣，像是取值、複製、合併、轉換型態、取代舊式 API…等等，這些都改善或簡化了 JavaScript 的邏輯程序，讓程式有了更多元的發展。</p><a id="more"></a><h2 id="概念與用途"><a href="#概念與用途" class="headerlink" title="概念與用途"></a>概念與用途</h2><ul><li>主要是展開單一個陣列 array，轉化為<strong>多個逗點隔開的獨立參數</strong></li><li>此運算子由三個點<code>...</code>組成，後面再加上你要轉換的陣列</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> spread = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(...spread); <span class="comment">// 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(...[<span class="string">'a'</span>, <span class="string">'b'</span>]); <span class="comment">// 'a' 'b'</span></span><br><span class="line"><span class="comment">// 等同於</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br></pre></td></tr></table></figure><ul><li>主要是用在<strong>執行函數時的參數列</strong>上</li><li>所以可以直接取代函數的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener"><code>apply()</code></a> 方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b + c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line">foo(...arr); <span class="comment">// 60</span></span><br><span class="line"><span class="comment">// 等同於</span></span><br><span class="line">foo.apply(<span class="literal">null</span>, arr); <span class="comment">// 60</span></span><br></pre></td></tr></table></figure><h2 id="使用特性"><a href="#使用特性" class="headerlink" title="使用特性"></a>使用特性</h2><ul><li>擴展了陣列本身，可以嵌入在陣列裡</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = [<span class="string">'x'</span>, <span class="string">'y'</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = [<span class="string">'w'</span>, ...a1, <span class="string">'z'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a2); <span class="comment">// ['w', 'x', 'y', 'z']</span></span><br></pre></td></tr></table></figure><ul><li>可以用來複製陣列</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = [...a1];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a2); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><ul><li>可以用來合併串聯多個陣列</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = [<span class="string">'Hello'</span>, <span class="string">'world'</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a2 = [...a2, ...a1];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a2); <span class="comment">// [1, 2, 3, 'Hello', 'world']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同於</span></span><br><span class="line">a2 = a2.concat(a1);</span><br></pre></td></tr></table></figure><ul><li>可以將字串展開為各單一字元</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = [...<span class="string">'Hello'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(text); <span class="comment">// ['H', 'e', 'l', 'l', 'o']</span></span><br></pre></td></tr></table></figure><h2 id="使用在物件上"><a href="#使用在物件上" class="headerlink" title="使用在物件上"></a>使用在物件上</h2><ul><li>根據<a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener">Object Rest/Spread Properties for ECMAScript Stage 3</a>的內容，其實<strong>物件</strong>也能夠使用這個運算子，只是目前還未正式加入 ES6 的標準中</li><li>基本上與陣列的使用方式大同小異，合併多個物件是非常實用的，甚至可以取代<code>Object.assign</code>方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">'foo'</span>, <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">'test'</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 複製物件</span></span><br><span class="line"><span class="keyword">let</span> clonedObj = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(clonedObj);  <span class="comment">// &#123; name: 'foo', x: 10 &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合併串聯多個物件</span></span><br><span class="line"><span class="comment">// 與陣列不同的是: 有相同屬性名的，合併後只會使用最後一個物件的內容值</span></span><br><span class="line"><span class="keyword">let</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(mergedObj);  <span class="comment">// &#123; name: 'test', x: 10, y: 20 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="其他應用"><a href="#其他應用" class="headerlink" title="其他應用"></a>其他應用</h2><ul><li>使用在陣列的 <code>push()</code> 方法上</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">list.push(...[<span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(list); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同於</span></span><br><span class="line">list.push.apply(list, [<span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure><ul><li>使用在 JavaScript 的自訂日期 Date 物件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>(...[<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>]);</span><br><span class="line"><span class="comment">// 等同於</span></span><br><span class="line"><span class="keyword">let</span> today = <span class="keyword">new</span> (<span class="built_in">Date</span>.bind.apply(<span class="built_in">Date</span>, [<span class="literal">null</span>, <span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(today); <span class="comment">// Thu Feb 01 2018 00:00:00 GMT+0800 (台北標準時間)</span></span><br></pre></td></tr></table></figure><ul><li>轉換型態，把類似陣列的資料轉換成真的陣列型態</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得 HTML DOM 使用到 querySelectorAll()</span></span><br><span class="line"><span class="comment">// 所得到的資料為 NodeList 物件結構</span></span><br><span class="line"><span class="keyword">const</span> nodeData = <span class="built_in">document</span>.querySelectorAll(<span class="string">'body'</span>);</span><br><span class="line"><span class="keyword">const</span> arrayData = [...nodeData];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nodeData);  <span class="comment">// NodeList [body]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayData); <span class="comment">// [body]</span></span><br></pre></td></tr></table></figure><hr><p>這個<code>...</code>擴展運算子與 ES6 中另一個新加入的 <strong>Rest 參數</strong>看起來很相似，但它們卻是相反的關係，下次的主題將會來解說到~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 加入了新的運算子&lt;code&gt;...&lt;/code&gt; Spread Operator，簡化了展開&lt;strong&gt;陣列&lt;/strong&gt;的過程，應用上真的非常廣，像是取值、複製、合併、轉換型態、取代舊式 API…等等，這些都改善或簡化了 JavaScript 的邏輯程序，讓程式有了更多元的發展。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6-重點紀錄" scheme="https://visionyi.github.io/categories/ES6-%E9%87%8D%E9%BB%9E%E7%B4%80%E9%8C%84/"/>
    
    
      <category term="JavaScript" scheme="https://visionyi.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://visionyi.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 樣板文字串 Template literals</title>
    <link href="https://visionyi.github.io/2018/01/01/ES6-series4-template-literals/"/>
    <id>https://visionyi.github.io/2018/01/01/ES6-series4-template-literals/</id>
    <published>2017-12-31T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.025Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 導入了樣板文字串 Template literals 是為了增強字串的表示方式，還能直接填入變數與表達式，可以更方便地輸出想要的文字組合了。</p><a id="more"></a><h2 id="使用特性"><a href="#使用特性" class="headerlink" title="使用特性"></a>使用特性</h2><ul><li>樣板文字串需使用<strong>反引號標識</strong><code>‵  ‵</code>包起來表示</li><li>可以寫入<strong>多行的字串</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可寫入多行的字串</span></span><br><span class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同於</span></span><br><span class="line">$(<span class="string">'#list'</span>).html(</span><br><span class="line">    <span class="string">'&lt;ul&gt;\n'</span> +</span><br><span class="line">      <span class="string">'&lt;li&gt;first&lt;/li&gt;\n'</span> +</span><br><span class="line">      <span class="string">'&lt;li&gt;second&lt;/li&gt;\n'</span> +</span><br><span class="line">    <span class="string">'&lt;/ul&gt;'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>可以<strong>嵌入變數或任何的表達式</strong>，需要使用<code>${ }</code>來嵌入</li><li>注意: <strong>換行與空白字元</strong>都會被保留，可使用字串的<code>trim()</code>方法來消除</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以嵌入變數</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span>);</span><br><span class="line"><span class="comment">// 'Hello Bob, how are you today?'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以嵌入任何表達式，例如函數、加減運算</span></span><br><span class="line"><span class="keyword">let</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">let</span> text = <span class="string">`The time and date is <span class="subst">$&#123;today.toLocaleString()&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(text);</span><br><span class="line"><span class="comment">// The time and date is 2018/1/1 下午6:10:10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 導入了樣板文字串 Template literals 是為了增強字串的表示方式，還能直接填入變數與表達式，可以更方便地輸出想要的文字組合了。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6-重點紀錄" scheme="https://visionyi.github.io/categories/ES6-%E9%87%8D%E9%BB%9E%E7%B4%80%E9%8C%84/"/>
    
    
      <category term="JavaScript" scheme="https://visionyi.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://visionyi.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 取值迴圈 for...of</title>
    <link href="https://visionyi.github.io/2017/12/30/ES6-series3-for-of/"/>
    <id>https://visionyi.github.io/2017/12/30/ES6-series3-for-of/</id>
    <published>2017-12-29T16:00:00.000Z</published>
    <updated>2018-09-16T03:47:17.025Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 新的迭代迴圈方法，基本上可以取代傳統上陣列的<code>forEach()</code>方法，另外這跟<code>for...in</code>迴圈很相似，但這兩者的用法是不同的，以下會多舉例比較他們之間的關係。</p><a id="more"></a><h2 id="概念與用途"><a href="#概念與用途" class="headerlink" title="概念與用途"></a>概念與用途</h2><ul><li>相對於<code>for...in</code>是取得物件的 “鍵名/屬性名”，而<code>for...of</code>是取得物件的 “鍵值/屬性值”</li><li>可以使用的範圍包括 Array、Set、Map、字串或實作迭代器(Iterator)介面的物件</li><li>除了可用在陣列結構上，主要還是用來獲取有迭代性質物件的內容</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...in 取得 "鍵名/屬性名"</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// '0' '1' '2' '3'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 取得 "鍵值/屬性值"</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 'a' 'b' 'c' 'd'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用在字串上</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">'Hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> string) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 'H' 'e' 'l' 'l' 'o'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用特性"><a href="#使用特性" class="headerlink" title="使用特性"></a>使用特性</h2><ul><li>for…of 迴圈只會返回<strong>具有數字索引屬性的內容</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">arr.text = <span class="string">'Hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.hasOwnProperty(i)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">//  '0', '1', '2', 'text'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 'a', 'b', 'c'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可使用陣列的<code>entries()</code>方法來獲取<code>[key, value]</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0, 'a'</span></span><br><span class="line"><span class="comment">// 1, 'b'</span></span><br><span class="line"><span class="comment">// 2, 'c'</span></span><br><span class="line"><span class="comment">// 3, 'd'</span></span><br></pre></td></tr></table></figure><ul><li>內層是陣列或物件類型的資料時，可以直接以<strong>解構賦值</strong>的方式去迭代循環取出<ul><li>如果取出的變數沒有對應到值，則會變成<code>undefined</code></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 內層為陣列類型時</span></span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="string">'Hello'</span>, <span class="string">'world'</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [x, y, z] <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3</span></span><br><span class="line"><span class="comment">// 4, 5, 6</span></span><br><span class="line"><span class="comment">// 'Hello', 'world', undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 內層為物件類型時</span></span><br><span class="line"><span class="keyword">let</span> family = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'ES6'</span>, <span class="attr">type</span>: <span class="string">'JavaScript'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'for'</span>, <span class="attr">type</span>: <span class="string">'Iterator'</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> &#123;name, type&#125; <span class="keyword">of</span> family) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name + <span class="string">': '</span> + type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'ES6: JavaScript'</span></span><br><span class="line"><span class="comment">// 'for: Iterator'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 新的迭代迴圈方法，基本上可以取代傳統上陣列的&lt;code&gt;forEach()&lt;/code&gt;方法，另外這跟&lt;code&gt;for...in&lt;/code&gt;迴圈很相似，但這兩者的用法是不同的，以下會多舉例比較他們之間的關係。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6-重點紀錄" scheme="https://visionyi.github.io/categories/ES6-%E9%87%8D%E9%BB%9E%E7%B4%80%E9%8C%84/"/>
    
    
      <category term="JavaScript" scheme="https://visionyi.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://visionyi.github.io/tags/ES6/"/>
    
  </entry>
  
</feed>
